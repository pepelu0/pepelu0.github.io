---
layout: post
title: 【翻译】非事务型分布式存储系统中的一致性
author: pepelu
date: 2019-09-10
online: false
tags:
    - 分布式
    - 一致性
---

***

原文地址: [Consistency in Non-Transactional Distributed Storage Systems](https://arxiv.org/pdf/1512.00168.pdf)

原作者: [Paolo Viotti](viotti@eurecom.fr) from EURECOM, [Marko Vukolic](mvu@zurich.ibm.com) from IBM Research - Zurich

***

# 摘要

近年来，关于分布式系统的讨论中，**一致性**这个词被赋予了不同的含义。在80年代，**一致性**的典型含义是**强一致性**，后来也叫**线性一致性**。近些年来，随着高可用性和扩展性的系统的诞生，**一致性**的含义被进一步弱化，模糊化。

通过这篇论文，我们旨在通过为分布式系统中存在的一致性概念提供一个结构化的，覆盖面较广的综述，来填补过去40年文献，尤其是存储系统研究中的空白。我们纵观了50多种不同的一致性概念，罗列出了从线性一致性，最终一致性，到弱一致性的概念，并准确给出了其中大部分的定义，尤其是那些之前有歧义的定义。
我们更进一步根据不同一致性概念的语义上的**强弱**，对其进行了部分排序。而且我们相信这些排序对今后的更深入的研究会非常有用。最后，我们将一致性的语义投射到不同的实际系统和研究的原型中。

这篇论文仅限于非事务的语义范围，比如那些单机存储的操作。同样的，这篇论文补足了现有对于事务，数据库一致性语义的研究。

# 1 介绍

面对失败，异步交互、计算和对共享资源的并发访问所带来的与生俱来的挑战，分布式系统的设计者们一直致力于通过提供抽象层或者不同层级的语义模型，来对用户屏蔽这些基础概念。第一眼看来，分布式系统的终极目标似乎很简单，理论上它只需要是一个具有容错性和扩展性的中心化系统。
换句话说，一个理想的分布式系统应该通过分布式和复制来屏蔽错误，提供扩展性，减小延迟，以增强可用性，但与此同时，需要维持中心化系统的简洁，尤其是一致性，需要让系统看起来像是串行访问一样。
如此强一致性的标准可以从早期的一些为现代存储系统打下重要基础的具有开创性意义的工作看到，比如【[Leslie Lamport, 1978](#leslielamport1978), [Leslie Lamport, 1986a](#leslielamport1986a)】【译者注：见引用文献】，
再比如后来进一步定义了一些普遍的，有实践意义的情况，比如**线性一致性**【[Herlihy and Wing, 1990](#herlihyandwing1990)】。

不幸的是，高可用和强一致性，尤其是线性一致性，在现实情况中，是相互冲突的。这些负面的理论结果，比如FLP不可能性定理【[Fischer et al., 1985](#fischeretal1985)】，CAP理论【[Gilbert and Lynch, 2002](#gilbertandlynch2002)】,为分布式系统设计画出了边界。
结论就是，分布式系统的设计者要么放弃高可用性和扩展性，要么降低一致性要求。

近些年，由于商业化，互联网规模系统的大量增加，系统设计者们往往选择可用性而非一致性，这也导致了弱一致性和最终一致性【[Terry et al., 1994](#terryetal1994); [Saito and Shapiro, 2005](#saitoandshapiro2005); [Vogels, 2008](#vogels2008)】概念的诞生。
因此，许多研究都聚焦在这些更弱的语义的理解【[Bailis and Ghodsi, 2013](#bailisandghodsi2013)】，适应【[Bailis et al., 2014](#bailisetal2014)】及代替更强语义【[Helland, 2007](#helland2007)】上。
沿着这条线继续探索，一些工具被设想出来，已试图从解决编程语言层面【[Alvaro et al., 2011](#alvaroetal2011)】，数据对象层面【[Shapiro et al., 2011a](#shapiroetal2011a); [Burckhardt et al., 2012](#burckhardtetal2012)】，
还有数据流层面【[Alvaro et al., 2014](#alvaroetal2014)】解决一致性问题。

在经历了将近40年对各种各样的一致性问题密集的又令人兴奋的研究过后，我们对分布式系统中存在的一致性概念还是缺乏一个结构化的，覆盖面较广的综述，尤其是存储系统。

这篇论文旨在通过对50多种不同的之前比较有歧义的一致性概念，从线性一致性一直到最终弱一致性，进行定义，以填补上述空白。我们更进一步的根据不同一致性概念语义上的强弱，对一致性概念进行了部分排序，而且我们相信这些排序对今后的更深入的研究会非常有用。
最后，我们将一致性的语义投射到不同的实际系统和研究的原型中。
这篇论文仅限于非事务的语义范围，比如那些单机存储的操作。我们研究的重点是越来越流行的非事务型的存储系统，这些系统实现起来相对容易，也有更好的扩展性。同样的，这篇论文补足了现有对于事务，数据库一致性语义的研究【[Adya, 1999](#adya1999)】，但由于篇幅优先，我们讨论的并不多。

本文的结构如下。在第2部分，我们定义了分布式系统的模型，为推演不同的一致性模型建立了一套框架。为了确保我们的工作尽可能全面，我们将我们的分布式模型设计成异步的，也就是说，没有设置计算和通信的时间约束。
我们的框架延续了【[Burckhardt, 2014](#burckhardt2014)】的工作，并通过分布式系统的**历史**和**抽象执行**描述了分布式系统动态的一面。我们定义一次执行为由某些进程触发的一系列在存储对象上的，通过它们的接口进行操作的动作集合。
为了分析**执行**，我们采用了**历史**的概念，也就是一次执行所对应的的操作的集合。通过分析历史上的所有信息，我们能获取到执行的固有的复杂性。
换句话说，我们可以将操作和他们对应的功能关联起来，并分组(比如，用执行操作的进程，操作的对象，或者用他们花费的时间)，或者依据执行过程中建立的动态关系(比如，因果关系)。
更进一步的，抽象执行增加了有序的操作所组成的历史，这些操作又决定了如何解决写冲突，也决定了他们在存储系统中的传播机制。

第3部分讲述了本论文的核心贡献: 一项对于50多种在非事务型存储系统中不同的一致性语义的调查。我们用第2部分锁提供的框架定义了许多模型，也就是使用图片实体上声明式的谓项逻辑语言的组合。
这些定义，反过来能帮助我们根据一致性语义上的强弱(第3部分图1)建立一套分层有序的一致性语义体系。为了更好的可读性，我们也根据一致性语义的特性，简略的总结出了10种不同的**家族**。

在第4部分，我们讨论了围绕着研究一致性问题的相关工作。在接下来的第5部分，我们进行了小结。我们最后总结本文中的所有一致性谓词(附录A)。对于我们工作中提到的所有一致性模型，我们也提供了它们对应的初始的定义，并提供了相关论文和实现(附录B)。
我们相信这篇论文将产生有用的贡献，因为它不仅仅能让分布式系统的研究人员，尤其能让学生，在面对大量的论文时，能很好的进行导览。

# 2 系统模型

在这一章中，我们着重解释了这篇论文后续所讨论的一致性概念中涉及的主要概念。就像【[Lynch and Tuttle, 1989](#lynchandtuttle1989)】和【[Herlihy and Wing, 1990](#herlihyandwing1990)】提到的，我们必须依赖并发对象抽象来定义基础的，静态的系统元素，比如对象和进程。
此外，为了系统中的动态行为，比如执行，我们依据【[Burckhardt, 2014](#burckhardt2014)】建立了计算框架。

## 2.1 一些前置的概念

* 对象和进程

   我们定义一个分布式的系统为一个以IO自动机【[Lynch and Tuttle, 1989](#lynchandtuttle1989)】为模型的，在一个全联通异步通信网络下的，与共享的(并发的)对象进行交互的，进程的有限集合。除非另有说明，进程和共享对象(或者简单的称之为对象)都是正确的，换句话说，他们不会失败。
   每一个进程和对象都有自己唯一的标识。我们定义*ProcessIds*为所有进程标识的集合，*ObjectIds*为所有对象标识的集合。

   另外，每一个对象都有唯一的对象类型。根据类型，对象可以从*Values*集合中取值(为了更好的可读性，我们使用了一种符号化表示：*Values*集合可以隐式地由对象类型参数化)，对象也支持一系列简单的操作类型集合(比如，*OpTypes = {rd,wr,inc,...}*)，这些集合约束了该对象上所有可能的操作。
   为了简便又不失普片性，除非特殊说明，否则下文中锁说的操作不是*reads(rd)*就是*writes(wr)*。换句话说，我们认定所有修改了对象值的操作为一次*write(or update)*操作，相反的，一次获取对象副本当前值，且不会修改它的操作为一次*read*操作。
   我们采用了对象副本，也可以简称为副本的概念，来代指在一个存储系统中为了容错或者提高性能而对为一个的共享对象存储的另一份完全相同的复制品。理论上，同一个共享对象的所有副本在同一时间的值应该完全相同。这种协同协议由共享对象的实现决定。

* 时间

   除非特别说明，我们认为异步计算和通信模型，都是没有计算和通信延迟的。然而，当描述特殊的一致性概念的时候，我们会使用诸如*渐进*和*过时*等词汇。这些词汇是相对*真实世界的时间*来说的。我们定义真实时间域为*Time*，它是一些正实数的集合，也叫*R*<sup>*+*</sup>。

## 2.2 操作，历史和抽象执行

* 操作

   我们定义一次操作为一个进程在一个共享对象上的元组(*proc,type,obj,ival,oval,stime,rtime*):

   * *$proc \in ProcessIds$*，表示一个出发操作的进程id
   * *$type \in OpTypes$*，表示操作类型
   * *$obj \in ObjectIds$*，表示操作的对象id
   * *$ival \in Values$*，表示操作的输入值
   * *$oval \in Values \cup \\{\nabla\\}$*，表示操作的输出值，如果操作没有返回，则为*$\nabla$*
   * *$stime \in Time$*，表示操作触发的时间
   * *$rtime \in Time \cup \\{\Omega\\}$*，表示操作返回的时间，如果操作没有返回，则为*$\Omega$*

   按照惯例，我们使用特殊值 *t ∈ Values* 代表如操作的输入(ival)和写操作的输出(oval)。简单起见，对于给定的操作 *op*，我们定义 *op.par* 来访问元组中的参数 *par* (比方说，*op.type* 代表了操作的类型，*op.ival* 代表了op的输入值)。

* 历史

  一次历史 *H* 是一个操作的集合。直观上来看，一次历史包含了一次执行所对应的所有操作。进一步的，<span>$H|_{wr}$</span> (或 <span>$H|_{rd}$</span>) 是一次给定的历史 *H* 的写(或读)操作的集合(举个例子， <span>$ H|_{wr} = \\{ op \in H : op.type = wr \\} $</span>)。

  我们更进一步的定义了历史中的元素之间的关系:

  * *rb(returns-before)* 表示 *H* 上按真实时间优先的自然偏序。形式上: <span>$rb \triangleq \\{(a,b):a,b \in H \land a.rtime<b.stime\\}$</span>
  * *ss(same-session)* 表示 *H* 上相同进程触发的一组操作的等价关系 - 我们说这些操作属于同一个 *session*。形式上: <span>$ss \triangleq \\{(a,b):a,b \in H \land a.proc=b.proc\\}$</span>
  * *so(session order)* 表示一个偏序，该偏序定义为: <span>$so \triangleq rb \bigcap ss$</span>
  * *ob(same-object)* 表示 *H* 上对相同对象触发的一组操作的等价关系。形式上: <span>$ob \in \\{(a,b):a,b \in H \land a.obj=b.obj\\}$</span>
  * *concur* 表示在同一个对象上的所有实时并发的操作的对称的二元关系。形式上: <span>$concur \triangleq ob \setminus rb$</span>

  对于<span>$(a,b) \in rel$</span>，我们有时也用<span>$a \xrightarrow{rel} b$</span>来表示。我们用<span>$rel_{-1}$</span>来表示与<span>rel</span>成反比。为了更紧密的符号，我们使用二元关系进行推演。
  例如，<span>$rel|_{wr->rd}$</span>表示属于<span>rel</span>的所有由一次写和一次读操作组成的操作对。
  此外，如果<span>rel</span>是一个等价关系，我们记<span>$a \approx _{rel}b \triangleq \lbrack a \xrightarrow{rel} b \rbrack$</span>。
  一个<span>H</span>上的等价关系<span>rel</span>会将<span>H</span>划分成等价类<span>$[a]_{rel}=\\{b \in H:b \approx _{rel} a\\}$</span>
  我们记<span>$H/\approx_{rel}$</span>来表示由<span>rel</span>确定的等价类集合。我们使用

# 引用文献

<a id="leslielamport1978">
* Leslie Lamport. 1978. Time, Clocks, and the Ordering of Events in a Distributed System.
  Communications of the ACM (CACM) 21, 7 (1978), 558–565.

<a id="leslielamport1986a">
* Leslie Lamport. 1986a. On Interprocess Communication. Part I: Basic Formalism. Distributed
  Computing 1, 2 (1986), 77–85.

<a id="herlihyandwing1990">
* Maurice Herlihy and Jeannette M. Wing. 1990. Linearizability: A Correctness Condition for
  Concurrent Objects. ACM Transactions on Programming Languages and Systems (TOPLAS)
  12, 3 (1990), 463–492.

<a id="fischeretal1985">
* Michael J. Fischer, Nancy A. Lynch, and Mike Paterson. 1985. Impossibility of Distributed
  Consensus with One Faulty Process. J. ACM 32, 2 (1985), 374–382. DOI:http://dx.
  doi.org/10.1145/3149.214121

<a id="gilbertandlynch2002">
* Seth Gilbert and Nancy A. Lynch. 2002. Brewer’s conjecture and the feasibility of consistent,
  available, partition-tolerant web services. SIGACT News 33, 2 (2002), 51–59.

<a id="terryetal1994">
* Douglas B. Terry, Alan J. Demers, Karin Petersen, Mike Spreitzer, Marvin Theimer, and Brent B.
  Welch. 1994. Session Guarantees for Weakly Consistent Replicated Data. In Parallel and
  Distributed Information Systems (PDIS). 140–149.

<a id="saitoandshapiro2005">
* Yasushi Saito and Marc Shapiro. 2005. Optimistic replication. Comput. Surveys 37, 1 (2005),
  42–81.

<a id="vogels2008">
* Werner Vogels. 2008. Eventually Consistent. Queue 6, 6 (Oct. 2008), 14–19. DOI:http:
  //dx.doi.org/10.1145/1466443.1466448

<a id="bailisandghodsi2013">
* Peter Bailis and Ali Ghodsi. 2013. Eventual Consistency Today: Limitations, Extensions,
  and Beyond. Queue 11, 3 (March 2013), 20:20–20:32. DOI:http://dx.doi.org/10.
  1145/2460276.2462076

<a id="bailisetal2014">
* Peter Bailis, Alan Fekete, Joseph M. Hellerstein, Ali Ghodsi, and Ion Stoica. 2014. Scalable
  atomic visibility with RAMP transactions. In ACM International Conference on Management
  of Data (SIGMOD), 2014. 27–38. DOI:http://dx.doi.org/10.1145/2588555.
  2588562

<a id="helland2007">
* Pat Helland. 2007. Life beyond Distributed Transactions: an Apostate’s Opinion. In Conference
  on Innovative Data Systems Research (CIDR), 2007. 132–141. http://www.cidrdb.
  org/cidr2007/papers/cidr07p15.pdf

<a id="alvaroetal2011">
* Peter Alvaro, Neil Conway, Joseph M. Hellerstein, and William R. Marczak. 2011. Consistency
  Analysis in Bloom: a CALM and Collected Approach. In Conference on Innovative Data
  Systems Research (CIDR), 2011. 249–260. http://www.cidrdb.org/cidr2011/
  Papers/CIDR11_Paper35.pdf

<a id="shapiroetal2011a">
* Marc Shapiro, Nuno M. Preguic¸a, Carlos Baquero, and Marek Zawirski. 2011a. Conflict-Free
  Replicated Data Types. In Stabilization, Safety, and Security of Distributed Systems (SSS),
  2011. 386–400. DOI:http://dx.doi.org/10.1007/978-3-642-24550-3_29

<a id="burckhardtetal2012">
* Sebastian Burckhardt, Manuel Fahndrich, Daan Leijen, and Benjamin P. Wood. 2012. Cloud ¨
  Types for Eventual Consistency. In Object-Oriented Programming (ECOOP), 2012. 283–307.
  DOI:http://dx.doi.org/10.1007/978-3-642-31057-7_14

<a id="alvaroetal2014">
* Peter Alvaro, Neil Conway, Joseph M. Hellerstein, and David Maier. 2014. Blazes: Coordination
  analysis for distributed programs. In IEEE Conference on Data Engineering (ICDE), 2014.
  52–63. DOI:http://dx.doi.org/10.1109/ICDE.2014.6816639

<a id="adya1999">
* Atul Adya. 1999. Weak Consistency: A Generalized Theory and Optimistic Implementations
  for Distributed Transactions. Ph.D. MIT, Cambridge, MA, USA. Also as Technical Report
  MIT/LCS/TR-786.

<a id="burckhardt2014">
* Sebastian Burckhardt. 2014. Principles of Eventual Consistency. Foundations and Trends in
  Programming Languages, Vol. 1. now publishers. 1–150 pages. http://research.
  microsoft.com/apps/pubs/default.aspx?id=230852

<a id="lynchandtuttle1989">
* Nancy A. Lynch and Mark R. Tuttle. 1989. An introduction to input/output automata. CWI
  Quarterly 2 (1989), 219–246.

<a id="herlihyandwing1990">
* Maurice Herlihy and Jeannette M. Wing. 1990. Linearizability: A Correctness Condition for
  Concurrent Objects. ACM Transactions on Programming Languages and Systems (TOPLAS)
  12, 3 (1990), 463–492.

<a id="burckhardt2014">
* Sebastian Burckhardt. 2014. Principles of Eventual Consistency. Foundations and Trends in
  Programming Languages, Vol. 1. now publishers. 1–150 pages. http://research.
  microsoft.com/apps/pubs/default.aspx?id=230852

<a id="lynchandtuttle1989">
* Nancy A. Lynch and Mark R. Tuttle. 1989. An introduction to input/output automata. CWI
  Quarterly 2 (1989), 219–246.