---
layout: post
title: 【翻译】非事务型分布式存储系统中的一致性
author: pepelu
date: 2019-09-10
online: false
tags:
    - 分布式
    - 一致性
---

***

原文地址: [Consistency in Non-Transactional Distributed Storage Systems](https://dl.acm.org/citation.cfm?id=2926965)

原作者: [Paolo Viotti](mailto:viotti@eurecom.fr) from EURECOM, [Marko Vukolic](mailto:mvu@zurich.ibm.com) from IBM Research-Zurich

***

# 摘要

近年来，在关于分布式系统的讨论中，"一致性"这个词汇被赋予了很多不同的含义。
在80年代，"一致性"通常指的是**强一致性**，后来也被叫作**线性一致性**，但近些年来，随着高可用性和高可扩展性的系统的诞生，不仅"一致性"的要求被弱化了，它本身的定义也变的越来越模糊。

通过这篇论文，我们旨在通过为分布式系统中存在的一致性概念提供一个结构化的，覆盖面较广的综述，来填补过去40年来各种文献，尤其是存储系统研究中的空白。
我们纵观了50多种不同的一致性概念，罗列出了从线性一致性，最终一致性，到弱一致性的概念，并准确给出了其中大部分的定义，尤其是那些之前有歧义的定义。
我们进一步根据不同一致性概念语义上的**强弱**，对其进行了部分排序。而且我们相信这些排序对今后的更深入的研究会非常有用。
最后，我们将一致性的语义和不同的实用系统及研究的原型系统关联在了一起。

这篇论文仅限于非事务的语义范围。就其这篇论文本身而论，它还弥补了现有对于事务，数据库一致性语义的研究中的不足。

# 1 介绍

面对失败处理，通信和计算的异步性，以及对共享资源的并发访问所带来的与生俱来的挑战，分布式系统的设计者们一直致力于通过提供抽象层和不同强度的语义模型，来对用户屏蔽这些基础概念。
乍一看，分布式系统的终极目标似乎很简单，理论上它只需要比中心化系统具有更好的容错性和扩展性即可。
换句话说，一个理想的分布式系统应该通过"分布"和"复制"来屏蔽错误，提供扩展性，减小延迟，最终以增强可用性，但与此同时，要能像使用中心化系统一样简洁。当然还有一致性，我们要让系统看起来像是在串行访问一样。
如此强一致性的标准可以从早期的一些为现代存储系统打下重要基础的，且具有开创性意义的工作看到，
比如[[Leslie Lamport,1978](#leslielamport1978), [Leslie Lamport, 1986a](#leslielamport1986a)]，
再比如后来的进一步定义了一些更为普遍的，更有实践意义的条件语义，如"线性一致性"[[Herlihy and Wing, 1990](#herlihyandwing1990)]。

不幸的是，高可用和强一致性，尤其是线性一致性，在现实情况中，是相互冲突的。这些负面的理论结果，比如FLP不可能性定理【[Fischer et al., 1985](#fischeretal1985)】，CAP理论【[Gilbert and Lynch, 2002](#gilbertandlynch2002)】,为分布式系统设计画出了边界。
结论就是，分布式系统的设计者要么放弃高可用性和扩展性，要么降低一致性要求。

近些年，由于商业化，互联网规模系统的大量增加，系统设计者们往往选择可用性而非一致性，这也导致了弱一致性和最终一致性【[Terry et al., 1994](#terryetal1994); [Saito and Shapiro, 2005](#saitoandshapiro2005); [Vogels, 2008](#vogels2008)】概念的诞生。
因此，许多研究都聚焦在这些更弱的语义的理解【[Bailis and Ghodsi, 2013](#bailisandghodsi2013)】，适应【[Bailis et al., 2014](#bailisetal2014)】及代替更强语义【[Helland, 2007](#helland2007)】上。
沿着这条线继续探索，一些工具被设想出来，已试图从解决编程语言层面【[Alvaro et al., 2011](#alvaroetal2011)】，数据对象层面【[Shapiro et al., 2011a](#shapiroetal2011a); [Burckhardt et al., 2012](#burckhardtetal2012)】，
还有数据流层面【[Alvaro et al., 2014](#alvaroetal2014)】解决一致性问题。

在经历了将近40年对各种各样的一致性问题密集的又令人兴奋的研究过后，我们对分布式系统中存在的一致性概念还是缺乏一个结构化的，覆盖面较广的综述，尤其是存储系统。

这篇论文旨在通过对50多种不同的之前比较有歧义的一致性概念，从线性一致性一直到最终弱一致性，进行定义，以填补上述空白。我们更进一步的根据不同一致性概念语义上的强弱，对一致性概念进行了部分排序，而且我们相信这些排序对今后的更深入的研究会非常有用。
最后，我们将一致性的语义投射到不同的实际系统和研究的原型中。
这篇论文仅限于非事务的语义范围，比如那些单机存储的操作。我们研究的重点是越来越流行的非事务型的存储系统，这些系统实现起来相对容易，也有更好的扩展性。同样的，这篇论文补足了现有对于事务，数据库一致性语义的研究【[Adya, 1999](#adya1999)】，但由于篇幅优先，我们讨论的并不多。

本文的结构如下。在第2部分，我们定义了分布式系统的模型，为推演不同的一致性模型建立了一套框架。为了确保我们的工作尽可能全面，我们将我们的分布式模型设计成异步的，也就是说，没有设置计算和通信的时间约束。
我们的框架延续了【[Burckhardt, 2014](#burckhardt2014)】的工作，并通过分布式系统的**历史**和**抽象执行**描述了分布式系统动态的一面。我们定义一次执行为由某些进程触发的一系列在存储对象上的，通过它们的接口进行操作的动作集合。
为了分析**执行**，我们采用了**历史**的概念，也就是一次执行所对应的的操作的集合。通过分析历史上的所有信息，我们能获取到执行的固有的复杂性。
换句话说，我们可以将操作和他们对应的功能关联起来，并分组(比如，用执行操作的进程，操作的对象，或者用他们花费的时间)，或者依据执行过程中建立的动态关系(比如，因果关系)。
更进一步的，抽象执行增加了有序的操作所组成的历史，这些操作又决定了如何解决写冲突，也决定了他们在存储系统中的传播机制。

第3部分讲述了本论文的核心贡献: 一项对于50多种在非事务型存储系统中不同的一致性语义的调查。我们用第2部分锁提供的框架定义了许多模型，也就是使用图片实体上声明式的谓项逻辑语言的组合。
这些定义，反过来能帮助我们根据一致性语义上的强弱(第3部分图1)建立一套分层有序的一致性语义体系。为了更好的可读性，我们也根据一致性语义的特性，简略的总结出了10种不同的**家族**。

在第4部分，我们讨论了围绕着研究一致性问题的相关工作。在接下来的第5部分，我们进行了小结。我们最后总结本文中的所有一致性谓词(附录A)。对于我们工作中提到的所有一致性模型，我们也提供了它们对应的初始的定义，并提供了相关论文和实现(附录B)。
我们相信这篇论文将产生有用的贡献，因为它不仅仅能让分布式系统的研究人员，尤其能让学生，在面对大量的论文时，能很好的进行导览。

# 2 系统模型

在这一章中，我们着重解释了这篇论文后续所讨论的一致性概念中涉及的主要概念。就像【[Lynch and Tuttle, 1989](#lynchandtuttle1989)】和【[Herlihy and Wing, 1990](#herlihyandwing1990)】提到的，我们必须依赖并发对象抽象来定义基础的，静态的系统元素，比如对象和进程。
此外，为了系统中的动态行为，比如执行，我们依据【[Burckhardt, 2014](#burckhardt2014)】建立了计算框架。

## 2.1 一些前置的概念

* 对象和进程

   我们定义一个分布式的系统为一个以IO自动机【[Lynch and Tuttle, 1989](#lynchandtuttle1989)】为模型的，在一个全联通异步通信网络下的，与共享的(并发的)对象进行交互的，进程的有限集合。除非另有说明，进程和共享对象(或者简单的称之为对象)都是正确的，换句话说，他们不会失败。
   每一个进程和对象都有自己唯一的标识。我们定义*ProcessIds*为所有进程标识的集合，*ObjectIds*为所有对象标识的集合。

   另外，每一个对象都有唯一的对象类型。根据类型，对象可以从*Values*集合中取值(为了更好的可读性，我们使用了一种符号化表示：*Values*集合可以隐式地由对象类型参数化)，对象也支持一系列简单的操作类型集合(比如，*OpTypes = {rd,wr,inc,...}*)，这些集合约束了该对象上所有可能的操作。
   为了简便又不失普片性，除非特殊说明，否则下文中所说的操作不是*reads(rd)*就是*writes(wr)*。换句话说，我们认定所有修改了对象值的操作为一次*write(or update)*操作，相反的，一次获取对象副本当前值，且不会修改它的操作为一次*read*操作。
   我们采用了对象副本，也可以简称为副本的概念，来代指在一个存储系统中为了容错或者提高性能而对为一个的共享对象存储的另一份完全相同的复制品。理论上，同一个共享对象的所有副本在同一时间的值应该完全相同。这种协同协议由共享对象的实现决定。

* 时间

   除非特别说明，我们认为异步计算和通信模型，都是没有计算和通信延迟的。然而，当描述特殊的一致性概念的时候，我们会使用诸如*渐进*和*过时*等词汇。这些词汇是相对*真实世界的时间*来说的。我们定义真实时间域为*Time*，它是一些正实数的集合，也叫*R*<sup>*+*</sup>。

## 2.2 操作，历史和抽象执行

* 操作

   我们定义一次操作为一个进程在一个共享对象上的元组(*proc,type,obj,ival,oval,stime,rtime*):

   * *$proc \in ProcessIds$*，表示一个出发操作的进程id
   * *$type \in OpTypes$*，表示操作类型
   * *$obj \in ObjectIds$*，表示操作的对象id
   * *$ival \in Values$*，表示操作的输入值
   * *$oval \in Values \cup \\{\nabla\\}$*，表示操作的输出值，如果操作没有返回，则为*$\nabla$*
   * *$stime \in Time$*，表示操作触发的时间
   * *$rtime \in Time \cup \\{\Omega\\}$*，表示操作返回的时间，如果操作没有返回，则为*$\Omega$*

   按照惯例，我们使用特殊值 *t ∈ Values* 代表如操作的输入(ival)和写操作的输出(oval)。简单起见，对于给定的操作 *op*，我们定义 *op.par* 来访问元组中的参数 *par* (比方说，*op.type* 代表了操作的类型，*op.ival* 代表了op的输入值)。

* 历史

  一次历史$H$是一个操作的集合。直观上来看，一次历史包含了一次执行所对应的所有操作。进一步的，$H\|\_{wr}$(或$H\|\_{rd}$) 是一次给定的历史$H$的写(或读)操作的集合(举个例子，$H\|\_{wr} = \{ op \in H : op.type = wr \} $)。

  我们更进一步的定义了历史中的元素之间的关系:

  * *rb(returns-before，在...之前返回)* 表示 *H* 上按真实时间优先的自然偏序。形式上: $rb \triangleq \{(a,b):a,b \in H \land a.rtime<b.stime\}$
  * *ss(same-session，同一次会话)* 表示 *H* 上相同进程触发的一组操作的等价关系 - 我们说这些操作属于同一个 *session*。形式上: $ss \triangleq \{(a,b):a,b \in H \land a.proc=b.proc\}$
  * *so(session order，会话顺序)* 表示一个偏序，该偏序定义为: $so \triangleq rb \bigcap ss$
  * *ob(same-object，同一个对象)* 表示 *H* 上对相同对象触发的一组操作的等价关系。形式上: $ob \in \{(a,b):a,b \in H \land a.obj=b.obj\}$
  * *concur* 表示在同一个对象上的所有实时并发的操作的对称的二元关系。形式上: $concur \triangleq ob \setminus rb$

  对于$(a,b) \in rel$，我们有时也用$a \xrightarrow{rel} b$来表示。我们用$rel^{-1}$来表示rel的反向关系。为了更紧密的符号，我们使用二元关系进行推演。
  例如，$rel\|\_{wr->rd}$表示属于rel的所有由一次写和一次读操作组成的操作对。
  此外，如果rel是一个等价关系，我们记$a \approx \_{rel}b \triangleq \lbrack a \xrightarrow{rel} b \rbrack$。
  一个H上的等价关系rel会将H划分成等价类$[a]\_{rel}=\{b \in H:b \approx \_{rel} a\}$
  我们记$H/\approx_{rel}$来表示由rel确定的等价类集合。我们通过使用函数:$H \xrightarrow{} 2^H$表示与一个操作并发的操作集来完善concur关系:

  $$
  \begin{equation}
  Concur(a) \triangleq \{b \in H|_{wr}:(a,b) \in concur\}
  \end{equation}
  $$

* 抽象执行

   我们按照【Burckhardt, [2014](#burckhardt2014)】用抽象执行的概念来为系统执行建模。一次抽象执行是在一次给定的历史H上的一个用H上的两个关系vis和ar所建立的多图$A=(H,vis,ar)$来表示。
   鉴于历史描述了执行的输出，vis和ar，直观的表述了异步环境的不确定性(比如，消息顺序)，和实现方法所带来的约束(比如，冲突恢复策略)。换句话说，vis和ar决定了历史中的操作之间的两两关系，以共同影响最终的输出。
   更具体的说

   * $vis(visibility，可见性)$ 是一个非循环的，自然的，用以表述写操作传播机制的关系。
   直观上，让a对b可见(也可表示为，$a \xrightarrow{vis} b$)的意义为：a操作所带来的影响可以被b操作看见(比如，b可以读到a写入的一个值)
   * $ar(arbitration，仲裁)$ 是历史中所有操作的全序，该全序体现了系统如何解决由并发操作的和不可见的操作产生的冲突。实践中，这种全序可以由多种方式实现:
   采用分布式时钟【Lamport, [1978](leslielamport1978)】或者一致性协议【Birman et al., [1991](#birmanetal1991); Hadzilacos and Toueg, [1994](#hardzilacosandtoueg1994); Lamport, [2001](#lamport2001)】,使用中心化的序列器，或确定性冲突解决机制。

   根据vis的约束不同，在执行过程中，不同的进程会观察到不同的写操作的顺序，我们称之为序列化。

   我们进一步的定义了happens-before(hb)(在XXX之前发生)顺序，它表示了so和vis并集上的传递闭包，表示为:

   $$
   \begin{equation}
   hb \triangleq (so \cup vis)^+
   \end{equation}
   $$

## 2.3 可复制数据类型和返回值一致性

   与其把当前系统的状态定义为由共享对象保存的值的集合【按照Burckhardt, [2014](#burckhardt2014)】，我们采用了一种叫做上下文的图抽象方式，该方式将一个抽象执行的信息进行编码，并映射到给定操作A的可见性(vis)上。
   形式上，给定C代表给定的抽象执行A上的所有操作的上下文集合，我们定义操作op的上下文为:

   $$
   \begin{equation}
   C=cxt(A,op) \triangleq A|_{op,vis^{-1}(op),vis,ar}
   \end{equation}
   $$

   更进一步的，我们引入了可复制数据类型【Burckhardt, [2014](#burckhardt2014)】的概念来定义在分布式系统上实现的共享对象的类型(比如，读/写寄存器，计数器，集合，队列等等)。
   对于每一种可复制数据类型，函数$\mathcal{F}$表示了操作$op \in H$在上下文中的返回值的集合，也可以记做$\mathcal{F}(op,cxt(A,op))$。用$\mathcal{F}$我们可以定义返回结果的一致性:

   $$
   \begin{equation}
   RV_{AL}(\mathcal{F}) \triangleq \forall op \in H : op.oval \in \mathcal{F}(op,cxt(A,op))
   \end{equation}
   $$

   本质上，返回值一致性是抽象执行上的一次断言，该断言保证了一次执行中的任何给定操作的返回值都属于预计返回值集合中。

   给定操作$b \in H$和它的上下文$cxt(A,b)$，让$a=prec(b)$表示在$ar$中b之前最后(唯一)一次操作，以致$a.oval \neq \nabla \land a \in H|_{wr} \cap vis^{-1}(b)$。
   换句话说，$prec(b)$是在由$ar$决定的顺序下$b$之前最后一次可见的写操作。如果没有这样的谦虚操作存在(比如，b是$ar$下的第一个操作)，为了方便起见，我们记$prec(b).ival$的默认值为$\bot$。

   在这篇论文中，我们采用读/写寄存器(也叫做读/写存储)作为参照的可复制数据类型，并用预期返回值方程表达:

   $$
   \begin{equation}
   \mathcal{F}_{reg}(op,cxt(A,op))=prec(op).ival
   \end{equation}
   $$

   需要注意的是，虽说这篇论文的焦点在读写存储上，但定义的一致性断言使用$\mathcal{F}$作为输入，因此我们可以直接扩展到其他可复制数据类型上。

## 2.4 一致性语义

   按照【Burckhardt, [2014](#burckhardt2014)】所说的，我们定义了一致性语义(有时也叫一致性保证)为抽象执行的属性和关系，表达为一阶逻辑断言。我们记$A \vDash \mathcal{P}$来表示一致性断言$\mathcal{P}$在抽象执行A上为真。
   因此，定义一个一致性模型，其实就是列举所有需要的一致性断言，并证明历史，至少其中的一次抽象执行，可以满足所有断言。

   形式上，对于给定的历史$H$和该历史中的所有可能的抽象执行$\mathcal{A}$，我们说该历史$H$满足所有一致性断言$\mathcal{P}_1$,...$\mathcal{P}_n$，当历史可以被扩展成一些抽象执行，并满足如下条件时:

   $$
   \begin{equation}
   H \vDash \mathcal{P}_1 \land \cdot \cdot \cdot \land \mathcal{P}_n \leftrightarrow \exists A \in \mathcal{A} : \mathcal{H}(A)=H \land A \vDash \mathcal{P}_1 \land \cdot \cdot \cdot \land \mathcal{P}_n
   \end{equation}
   $$

   在上述的符号中，对于给定的抽象执行$A=(H,vis,ar)$，$\mathcal{H}(A)$表示$H$。

# 3 非事务性一致性语义

   在这一部分，我们分析调查了采用单独操作作为首选的系统的一致性语义(也叫做，非事务性一致性语义)。这篇文章中剩余的部分所描述的一致性模型都在下图中，该图综合地根据一致性语义的强弱给出了他们之间的偏序关系，同时把一致性模型划分成了不同的"家族"。
   此分类不仅描绘了一致性语义的强弱不同，也根据他们定义的不同归纳出了共通的因素。

   这部分生下来的内容，我们分别调查了不同家族的一致性语义。3.1中介绍了线性一致性和其他的强一致性模型。3.2中介绍了最终一致性和弱一致性。接下来我们分析了PRAM和顺序一致性(3.3)。3.4中介绍了基于会话的模型。3.5中介绍了因果一致性。3.6中讨论了基于旧数据的模型。
   3.7中讨论了基于分支的模型。3.8和3.0中讨论了可调优的和基于对象的语义。最后，我们在3.10中分析了基于同步的一致性模型家族。

   ![models](/assets/Hierarchy of non-transactional consistency models.jpg)

   图1: 非事务一致性模型的层级关系。由一致性语义A指向B的有向边表示任何满足B的执行也满足A。带下划线的模型表明有时间上的保证。

## 3.1 线性一致性和与其相关的强一致性语义

   非一致性系统中的最高标准和核心一致性模型就是线性一致性，由【Herlihy and Wing, [1990](herlihyandwing1990)】定义。粗略的讲，线性一致性是一种正确的状况，在该状况下，每一个操作都会在调用和返回之间的某个时间点立即生效。
   线性一致性，也经常非正式的被称作强一致性，长期以来都被认为是分布式存储需要实现的理想正确性。线性一致性具有局部性: 一个可线性化的对象的组合本身也是可线性化的 - 因此，线性一致性是可以被模块化和证明的。

   如此强的语义，尽管很容易用直觉理解，缺非常难以实现。就这一点而言，【Gilbert and Lynch, [2002](#gilbertandlynch2002)】，形式化的证明了CAP理论。
   该理论【Johnson and Thomas, [1975](#johnsonandrobert1975); Davidson et al., [1985](#davidsonetal1985); Coan et al., [1986](#coanetal); Brewer, [2000](#brewer2000)】都非正式的提出过。
   该理论将一个系统在面对网络分区时的维持非凡水准的能力与线性一致性关联起来。简单来说，CAP理论指出，当网络分区发生的时候，一个分布式存储系统必须在可用性和线性一致性中间二选一。

   [Burckhardt, [2014](#burckhardt2014)]将线性一致性分解为3个部分:

   $$
   \begin{equation}
   L_{INEARIZABILITY}(\mathcal{F}) \triangleq S_{INGLE}O_{RDER} \land R_{EAL}T_{IME} \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   在这个公式中:

   $$
   \begin{equation}
   S_{INGLE}O_{RDER} \triangleq \exists H' \subseteq \{ op \in H : op.oval = \nabla \} : vis=ar \setminus (H' \times H)
   \end{equation}
   $$

   $$
   \begin{equation}
   R_{EAL}T_{IME} \triangleq rb \subseteq ar
   \end{equation}
   $$

   换句话说，$S_{INGLE}O_{RDER}$利用了一个单一的整体顺序，并定义了$vis$和$ar$，$REALTIME$使得仲裁($ar$)顺应了returns-before偏序($rb$)。
   最后，$RV_{AL}(\mathcal{F})$指定了可复制数据类型的返回值一致性。我们回忆一下公式(5)，在读写存储的例子中，它表示了最后一次写(由$ar$决定)之后的读操作$rd$所读取到的值。

   一个和线性一致性紧密关联的概念，原子寄存器语义，由【Lamport, [1986b](#lamport1986b)】提出。Lamport描述了一个单写多读(SWMR, single-writer multi-reader)的共享寄存器。
   该寄存器是原子的当且仅当每一个不与写操作重叠的读操作都会正确的返回寄存器上的最后一个写入的值，且如果读操作顺序执行的话，他们返回的值应该是一样的。
   本质上，该定义描绘的是在共享寄存器上的一个个时间上的点(线性点)。我们很容易感受到原子性和线性一致性在读写寄存器上是等价的。然而，线性一致性是在普片意义共享数据结构上的更通用的定义，这些数据结构能够支持更多的操作语义。
   除了原子寄存器，Lamport【[1986b](#lamport1986b)】定义了两个在SWMR寄存器上更弱的语义: **safe**和**regular**。在不考虑读写并发的情况下，他们都能保证一个读操作返回最后一个写入的值，就像原子语义一样。
   他们仨的不同之处在于读写并发的时候读操作的返回值。换句话说，**safe**寄存器上，一个和许多写操作并发的读操作可能返回任何值。相反的，在**regular**寄存器上，一个和许多写操作并发的读操作要不返回最近一次完整写操作的值，要不返回与之并发的写操作的值。
   不同如下图所示:

   ![read write concurrency](/assets/read_write concurrency.png)

   *图2: 读写并发示例(时间发生顺序由左至右)。寄存器初始值为0。原子(线性)语义下x只能是0或者1。Regular语义下x可以是0，1或者2。safe语义下x可以是任意值。*

   形式上，**regular**和**safe**语义可以定义为:

   $$
   \begin{equation}
   R_{EGULAR}(\mathcal{F}) \triangleq S_{INGLE}O_{RDER} \land R_{EAL}T_{IME}W_{RITES} \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   $$
   \begin{equation}
   S_{AFE}(\mathcal{F}) \triangleq S_{INGLE}O_{RDER} \land R_{EAL}T_{IME}W_{RITES} \land S_{EQ}RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   其中

   $$
   \begin{equation}
   R_{EAL}T_{IME}W_{RITES} \triangleq rb|_{wr \rightarrow op} \subseteq ar
   \end{equation}
   $$

   是仅对写操作的真实时间顺序上的约束。

   $$
   \begin{equation}
   S_{EQ}RV_{AL}(\mathcal{F}) \triangleq \exists op \in H : Concur(op) = \varnothing \Rightarrow op.oval \in \mathcal{F}(op,cxt(A,op))
   \end{equation}
   $$

   约束了与任意写操作并发的读操作的返回值一致性。

## 3.2 弱一致性和最终一致性

   在一致性频谱的另一端是**弱**一致性。尽管这个词在很多文献中都表示任何比顺序一致性更低的一致性模型，
   但最近的论文【Vogels, [2008](#vogels2008); Bermbach and Kuhlenkamp, [2013](#bermbachandkuhlenkamp2013)】给了它一个更加独特，尽管还是很模糊的定义: 一个弱一致性系统不保证读操作能返回最近一次写操作的值。效果上，弱一致性没有顺序保证 - 因此，也不需要同步协议。
   尽管这个模型看上去没什么用，但它却说明了实现同步协议是代价高昂的，副本之间偶尔的交换信息其实已经足够管用了。
   举个例子，一个典型的弱一致性应用就是网络应用中的层层直至浏览器的缓存策略。

   **最终**一致性比弱一致性要略强一些。从字面意思理解，在最终一致性下，如果没有进一步的更新操作，副本之间会逐渐统一成同一份拷贝。
   换句话说，如果没有新的写操作，最终所有读操作都会返回相同的值。最终一致性最初由【Terry et al. [1994](#terryetal1994)】定义，并由【Vogels, [2008](#vogels2008)】通过引入高可用存储系统(也就是CAP理论中的AP系统)在10多年之后发扬光大。
   最终一致性特别适合那些协调实现起来不是很现实，或者实现代价比较高昂的场景(比如，在移动或者广域设置上)【Saito and Shapiro, [2005](#saitoandshapiro2005)】。尽管应用广泛，最终一致性将短时间异常的可能留个给了应用层的开发者 - 也就是所有那些偏离线性一致性执行的理论结果的行为。
   因此，最近有大量的工作都旨在更好的理解一致性模型和其精妙的实现【Bermbach and Tai, [2011](#bermbachandtai2011); Bernstein and Das, [2013](#bernsteinanddas2013); Bailis and Ghodsi, [2013](#bailisandghodsi2013); Bailis et al., [2014](#bailisetal2014)】。
   其核心观点是，最终一致性约束了副本的最终状态(也叫做他们的收敛): 事实上，它并没有提供任何关于操作时效性和顺序的任何保障。【Burckhardt, [2014](#burckhardt2014)】提出了最终一致性形式上的定义:

   $$
   \begin{equation}
   E_{VENTUAL}C_{ONSISTENCY}(\mathcal{F}) \triangleq E_{VENTUAL}V_{ISIBILITY} \land N_{O}C_{IRCULAR}C_{AUSALITY} \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   其中，

   $$
   \begin{equation}
   E_{VENTUAL}V_{ISIBILITY} \triangleq \forall a \in H, \forall[f] \in H \approx_{ss}: |\{b \in [f] : (a \xrightarrow{rb} b) \land (a \not\xrightarrow{vis} b\}| \lt \infty
   \end{equation}
   $$

   表示最终，操作$op$在完全执行完成之后对于另一个操作$op'$是可见的。

   $$
   \begin{equation}
   N_{O}C_{IRCULAR}C_{AUSALITY} \triangleq acyclic(hb)
   \end{equation}
   $$

   表明非循环的hb关系(公式2中锁定义的)。

   在一个最终一致性的替代定义中，【Shapiro et al., [2011a](#shapiroetal2011a)】从副本集的角度给出了如下说明:

   * 最终交付: 如果一个正确的副本应用了一次写操作$op$，$op$最终会被应用到所有的正确的副本;

   * 收敛: 所有应用了相同写操作的的正确的副本最终会到达相同的状态;

   * 终止: 所有操作完成。

   对于以上最终一致性的定义，【Shapiro et al., [2011a](#shapiroetal2011a)】增加了如下约束:

   * 强收敛: 所有应用了相同写操作的副本拥有相同的状态。

   换句话说，最后这条保证了任意两个应用了相同(可能顺序不同)写操作的副本中的数据完全相同。一个系统如果实现了最终一致性和强收敛，我们则可称之为强最终一致性。

   我们从读操作的角度解读一下强收敛，那就是对于完全一致的可见写操作的集合，读操作会返回相同结果。

   $$
   \begin{equation}
   S_{TRONG}C_{ONVERGENCE} \triangleq \forall a,b \in H|_{rd} : vis^{-1}(a)|_{wr} = vis^{-1}(b)|_{wr} \implies a.oval=b.oval
   \end{equation}
   $$

   然后，强最终一致性可以定义为:

   $$
   \begin{equation}
   S_{TRONG}E_{VENTUAL}C_{ONSISTENCY}(\mathcal{F}) \triangleq E_{VENTUAL}C_{ONSISTENCY}(\mathcal{F}) \land S_{TRONG}C_{ONVERGENCE}
   \end{equation}
   $$

   **静态一致性**【Herlihy and Shavit, [2008](#herlihyandshavit2008)】指的是，如果一个对象停止接收更新(也就是说，静态了)，那么在这个对象上的执行等价于只包含已完成操作的顺序执行。
   尽管这个定义很像最终一致性，但它并不保证终止: 如果一个系统不停止接收更新，那么它不会到达静态，也不会到达副本收敛。根据【Burckhardt, [2014](#burckhardt2014】，我们形式化的定义静态一致性为:

   $$
   \begin{equation}
   Q_{UIESCENT}C_{ONSISTENCY}(\mathcal{F}) \triangleq |H|_{wr}| \lt \infty \implies \\
   \exists C \in \mathcal{C} : \forall [f] \in H/ \approx_{ss} : |\{op \in [f] : op.oval \notin \mathcal{F}(op,C)\}| \lt \infty
   \end{equation}
   $$

## 3.3 PRAM和顺序一致性

   管道RAM(PRAM或者先进先出)一致性【Lipton and Sandberg, [1988](#liptonandsandberg1988)】规定，所有进程看见的由一个进程产生的写操作的顺序，应该和该进程实际执行这些写操作的顺序保持一致。
   另一方面，进程观察到的其他不同进程所执行的写操作的顺序可以不同。也就是说，在这种一致性下，并没有要求有一个全局一致的操作顺序，而由一个指定进程产生的所有写操作必须有序，就想他们在一条管道中一样，PRAM也因此得名。
   我们通过要求可见的偏序(vis)是会话顺序(so)的一个超集来定义PRAM:

   $$
   \begin{equation}
   PRAM \triangleq so \subseteq vis
   \end{equation}
   $$

   就像【Brzezinski et al. [2003](#brzezinskietal2003)】提到的，PRAM一致性能得到保证当且仅当系统提供读你所写，单调读，单调写保证。这些概念我们将在3.4部分介绍。

   当一个系统实现了顺序一致性，所有的操作在所有的副本上都有相同的顺序，并且每一个进程决定的操作顺序是被保护的。形式上:

   $$
   \begin{equation}
   S_{EQUENTIAL}C_{ONSISTENCY}(\mathcal{F}) \triangleq S_{INGLE}O_{RDER} \land PRAM \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   因此，由【Lamport, 1979(#lamport1979)】提出的顺序一致性，更像是一种顺序保证，而不是时效性保证。
   像线性一致性一样，顺序一致性强制了操作的全局通用顺序。和线性一致性不同的是，顺序一致性不要求操作在不同的会话间保证真实时间的顺序，而只要在同一个进程中执行操作的真实时间顺序得到保证(就像PRAM一致性一样)。
   一个顺序一致性和线性一致性能力及实现的代价的定量对比，由【Attiya and Welch, [1994](#attiyaandwelch1994)】提出。

   ![3](/assets/An execution with processes issuing write operations on a shared object.png)

   图3: 在共享对象上执行写操作。黑色的点表示线性一致性的点。

   图3表示一个共享对象上的由两个进程执行的写操作。我们假设这两个进程都在一直执行读操作。每一个进程都会观察到一个特定的写操作顺序。如果我们假设系统实现了PRAM一致性，这两个进程，可能会观察到如下的结果:

   $$
   \begin{equation}
   S_{P_{A}}: W_{1} \phantom{2} W_{2} \phantom{2} W_{3} \phantom{2} W_{5} \phantom{2} W_{4} \phantom{2} W_{7} \phantom{2} W_{6} \phantom{2} W_{8} \tag{S.1}
   \end{equation}
   $$

   $$
   \begin{equation}
   S_{P_{A}}: W_{1} \phantom{2} W_{3} \phantom{2} W_{5} \phantom{2} W_{7} \phantom{2} W_{2} \phantom{2} W_{4} \phantom{2} W_{6} \phantom{2} W_{8} \tag{S.2}
   \end{equation}
   $$

   如果系统实现了顺序一致性，那么$S_{P_{A}}$应该和$S_{P_{B}}$完全一致，并且其他所有写进程都应该尊崇这个顺序。因此，(S.1)或(S.2)都能被接受。另一方面，如果系统实现的事线性一致性，并且按照图3中的黑色点锁表示的顺序的话，应该是:

   $$
   \begin{equation}
   S_{P_{A}}: W_{1} \phantom{2} W_{3} \phantom{2} W_{2} \phantom{2} W_{4} \phantom{2} W_{5} \phantom{2} W_{6} \phantom{2} W_{8} \phantom{2} W_{7} \tag{S.3}
   \end{equation}
   $$

## 3.4 会话内一致性保证(Session guarantees)

   会话内一致性保证由【Terry et al., [1994](#terryetal1994)】提出。尽管此概念最初是用来描述和客户端的会话链接的，但会话内一致性保证也可以适应更宽泛的会话定义中，并可以从进程的角度阐述执行问题。
   我们注意到之前的一些工作也将绘画内一致性保证说成是客户端中心模型(client-centric models)【Tanenbaum and van Steen, [2007](#tanenbaumandvansteen2007)】。

   **单调读(Monotonic reads)** 要求连续的读请求必须反映出一个非递减的写操作集合。也就是说，如果一个进程已经读到了一个对象上的值$v$，任何一个接下去的读操作都不会返回值$v$之前的写入值。
   直观来看，读操作只能在那些发出该读操作的进程已经观察到的写操作都被执行过的副本上进行。
   实际上，我们可以这么描述: 给定三个操作$a,b,c \in H$，如果$a \xrightarrow{vis} b$，且$b \xrightarrow{so} c$，其中$b$和$c$都是读操作，那么$a \xrightarrow{vis} c$，换句话说，$vis$和$so$的传递闭包包含在$vis$中。

   $$
   \begin{equation}
   M_{ONOTONIC}R_{EADS} \triangleq \forall a \in H, \forall b,c \in H|_{rd}: a \xrightarrow{vis} b \land b \xrightarrow{so} c \implies a \xrightarrow{vis} c \triangleq (vis;so|_{rd \rightarrow rd}) \subseteq vis
   \end{equation}
   $$

   **读你所写(Read-your-writes)** 保证(也叫读我所写，【Terry et al., [2013](#terryetal2013); Burckhardt, [2014](#burckhardt2014)】)要求由一个进程产生的读操作只能由已经执行过所有该进程产生的写操作的副本执行。

   $$
   \begin{equation}
   R_{EAD}Y_{OUR}W_{RITES} \triangleq \forall a \in H|_{wr}, \forall b \in H|_{rd}: a \xrightarrow{so} b \implies a \xrightarrow{vis} b \triangleq so|_{wr \rightarrow rd} \subseteq vis
   \end{equation}
   $$

   让我们假设两个进程在同一个共享对象上执行读写操作，如图4所示

   ![4](/assets/An execution with processes issuing read and write operations on a shared object.png)

   图4: 在共享对象上执行读写操作

   给定该执行，如果$P_{A}$和$P_{B}$满足读你所写保证，但又不满足PRAM一致性，我们可能会看到如下的顺序:

   $$
   \begin{equation}
   S_{P_{A}}: W_{1} \phantom{2} W_{3} \phantom{2} W_{4} \phantom{2} W_{2} \tag{S.4}
   \end{equation}
   $$

   $$
   \begin{equation}
   S_{P_{A}}: W_{2} \phantom{2} W_{4} \phantom{2} W_{3} \phantom{2} W_{1} \tag{S.5}
   \end{equation}
   $$

   我们注意到一些文献中的将会话内一致性视为读你所写一致性的一种特殊情况，并可以通过粘性客户端会话来实现。换句话说，进程产生的这些会话都会被指向同一个给定的副本。

   在一个保证**单调写（）**的系统中，会话的一次写操作只能在那些该会话之前的写操作都被执行的副本上执行。换句话说，副本必须按一次会话的写操作申请顺序执行它们。

   $$
   \begin{equation}
   M_{ONOTONIC}W_{RITES} \triangleq \forall a,b \in H|_{wr} : a \xrightarrow{so} b \implies a \xrightarrow{ar} b \triangleq so|_{wr \rightarrow wr} \subseteq ar
   \end{equation}
   $$

   **写后读一致性(Writes-follow-reads)**，有时也叫会话因果，跟读你所写一致性有点相反，它保证了一次会话中的写操作一定在该写操作之前的读操作所看见的所有写操作之后被执行。

   $$
   \begin{equation}
   W_{RITES}F_{OLLOW}R_{EADS} \triangleq \forall a,c \in H|_{wr}, \forall b \in H|_{rd} : a \xrightarrow{vis} b \land b \xrightarrow{so} c \implies a \xrightarrow{ar} c \triangleq (vis;so|_{rd \rightarrow wr}) \subseteq ar
   \end{equation}
   $$

   我们发现一些会话内一致性保证嵌入了一些因果概念，这些概念都包括在由【Brzezinski et al., [2004](#brzezinskietal2004)】提出的因果一致性概念中。我们将在接下来的章节中讨论。

## 3.5 因果模型

   被人们普片认知的分布式系统中的潜在因果关系被包含在了由【Lamport, [1987](#lamport1987)】提出的$在...之前发生(happened-before)$关系中。根据此关系，两个操作$a$和$b$是有序的，当(a)他们都是同一个线程的操作，(b)$b$读取了$a$写入的值，(c)他们是由(a)和/或(b)组成的传递闭包。
   这个通常被定义在消息传递系统中的概念，由【Hutto and Ahamad, [1990](#huttoandahamad1990)】翻译成了共享内存系统的一致性条件。
   潜在的因果关系建立在操作的偏序关系上，也就是我们在公式(2)中提到的$hb$。
   因此，具有潜在因果关系(尽管最恰当的术语应该是"潜在英国关系"，为了简单起见，下文中我们还是称之为"因果关系")的的操作在所有进程看来有相同的顺序，不具有因果关系(也叫因果并发)的操作在所有进程看来可能有不同的顺序。
   换句话说，因果一致性规定了对于有因果关系的操作【Hutto and Ahamad, [1990](#huttoandahamad1990); Ahamad et al., [1995](#ahamadetal1995); Mahajan et al., [2011](#mahajanetal2011)】，所有副本所见的顺序必须相同。
   这种模型可以用两个谓词描述【Burckhardt, [2014](#burckhardt2014)】:

   * $C_{AUSAL}V_{ISIBILITY} \triangleq hb \subseteq vis$

   * $C_{AUSAL}A_{RBITRATION} \triangleq hb \subseteq ar$

   因此，因果一致性可以被定义为:

   $$
   \begin{equation}
   C_{AUSALITY}(\mathcal{F}) \triangleq C_{AUSAL}V_{ISIBILITY} \land C_{AUSAL}A_{RBITRATION} \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   图5表示了两个进程读写一个共享对象的执行，箭头表示了操作间的因果关系。
   假设执行遵循PRAM一致性但是不满足因果一致性，我们或许能得到如下的序列:

   $$
   \begin{equation}
   S_{P_{A}}: W_{1} \phantom{2} W_{2} \phantom{2} W_{4} \phantom{2} W_{5} \phantom{2} W_{3} \phantom{2} W_{6} \tag{S.6}
   \end{equation}
   $$

   $$
   \begin{equation}
   S_{P_{B}}: W_{3} \phantom{2} W_{6} \phantom{2} W_{1} \phantom{2} W_{2} \phantom{2} W_{4} \phantom{2} W_{5} \tag{S.7}
   \end{equation}
   $$

   ![5](\assets\An execution with processes issuing operations on a shared object.png)

   图5: 在共享对象上由多进程执行操作。箭头指示了操作间的因果关系。

   最近由【Bailis et al., [2012](#bailisetal2012)】提出的明确的应用层因果关系的使用，是潜在因果关系的一个子集(正如【Bailis et al., [2012](#bailisetal2012)】中所讨论的，应用层因果关系图在广度和深度上都比传统的因果关系更小，因为它只囊括了相关的因果关系，关注于应用层面向用户的一面)，
   应用层因果关系是为了使高可用系统能够花费更小的开销在协调和元数据的维护上。
   此外，因果一致性有一些更进一步的研究，在用户能感受到的正确性和协调的代价之前做出权衡，尤其是在移动应用和多区域副本应用【Lloyd et al., [2011](#lloydetal2011); Bailis et al., [2013](#bailisetal2013); Zawirski et al., [2015](#zawirskietal2015)】。

   **因果+(或者叫收敛因果)** 一致性【Lloyd et al., [2011](#lloydetal2011)】指出，在因果一致性的基础上，所有副本将会最终且独立的解决冲突。事实上，因果并发的写操作可能会产生一些冲突，在收敛因果一致性的系统中也是依赖交换性和结核性函数来处理的。
   本质上，因果+用强收敛性(参见公式(17))强化了因果一致性，这使得所有应用了相同写操作的正确副本都处在相同的状态下。在某种意义下，因果+一致性通过强收敛性强化了因果一致性，就像强最终一致性【Shapiro et al., [2011a](#shapiroetal2011a)】强化了最终一致性。
   因此，因果+一致性可以被表示为:

   $$
   \begin{equation}
   C_{AUSAL+}(\mathcal{F}) \triangleq C_{AUSALITY}(\mathcal{F}) \land S_{TRONG}C_{ONVERGENCE}
   \end{equation}
   $$

   **真实时间因果**一致性由[Mahajan et al., [2011](#mahajanetal2011)]提出，它是一个比因果一致性更严格的条件，它强制使得: 在真实时间上不重叠的因果并发写操作，必须按照他们的真实时间被副本应用。

   $$
   \begin{equation}
   R_{EAL}T_{IME}C_{AUSALITY}(\mathcal{F}) \triangleq C_{AUSALITY}(\mathcal{F}) \land R_{EAL}T_{IME}
   \end{equation}
   $$

   其中$R_{EAL}T_{IME}$的定义在公式(9)中。

   我们觉得，尽管[Lloyd et al., [2011](#lloydetal2011)]认为真实时间因果一致性比因果+一致性要强，但我们认为他们不具有可比性。因为真实时间因果一致性 - 就像[Mahajan et al., [2011](#mahajanetal2011)]定义的那样 - 并没有支持强收敛性。
   当然，你可以设计一个真实时间因果一致性的变种来支持强收敛性。

   [Attiya et al., [2015](#attiyaetal2015)]定义了多值寄存器(MVR, multi-value registers)上的$可观察因果一致性$，它比因果一致性要强，因为它可以暴露进程通过观察推测出的操作间的并发。
   可观察因果一致性也被证明是实现了多寄存器的高可用数据存储上最强的一致性模型。

## 3.6 基于过时一致性的模型

   直觉上来看，基于过时一致性的模型允许读操作返回老的，失效的写入值。这些模型提供比最终一致性更强的保障，但和线性一致性相比却足够"弱"以致于我们可以用更高效的方式实现。在文献中，我们使用两个指标衡量旧: (真实)时间和数据(对象)的版本。

   就我们所掌握的知识，第一个基于时间失效一致性模型的形式化描述是[Singla et al., [1997](#singlaetal1997)]提出**delta**一致性。根据delta一致性，写操作保证在最多$t+delta$个时间单位后可见。
   此外，delta一致性是和一个顺序判定(我们将在3.9中介绍慢内存一致性模型)一起定义的: 由同一个进程写入同一个对象的操作，在所有进程看来都有相同的顺序，但是对于不同进程写入同一个对象的操作来说，并没有要求全局有序。

   类似的，限时一致性(timed consistency)模型[Torres-Rojas et al., [1999](#torresrojasetal1999)]，约定了从开始写入的固定时间之后，读操作返回的数据集。
   特别的，在限时可串行化中，所有读操作都准时发生，也就是说，只要还有已经持续了$\Delta$个时间单位的最新值存在，那么读操作就不会返回比该值还老的值。其中$\Delta$为本次执行的一个参数。
   换句话说，与delta一致性类似，如果一个写请求在时间点t被执行，那么该写请求写入的值，将在t+$\Delta$之前被所有进程所见。

   [Mahajan et al., [2010](#mahajanetal2010)]定义了有界的旧，它的核心思想和定时一致性和delta一致性语义类似: 一个写请求应当在一个固定的时间内被所有进程所见。
   然而，该定义也和周期性的消息相关，这种消息让每一个进程保持都保持其他进程的所有跟新，如果丢失了更新，则会挂起进程。
   delta一致性，限时一致性和有界过时的区别事实上只在于微妙的实现细节上，这些细节源于不同的上下文及他们实践的目的。
   因此，我们可以用形式化的方式描述以上三者:

   $$
   \begin{equation}
   T_{IMED}V_{ISIBILITY}(\Delta) \triangleq \forall a \in H|_{wr}, \forall b \in H, \forall t \in Time: a.rtime = t \land b.stime = t + \Delta \implies a \xrightarrow{vis} b
   \end{equation}
   $$

   **限时因果**一致性[Torres-Rojas and Meneses, [2005](#torresrojasandmeneses2005)]保证了每一个执行都遵循因果一致性的偏序，同时也保证所有读都会在$\Delta$时间内及时返回:

   $$
   \begin{equation}
   T_{IMED}C_{AUSALITY}(\mathcal{F},\Delta) \triangleq C_{AUSALITY}(\mathcal{F}) \land T_{IMED}V_{ISIBILITY}(\Delta)
   \end{equation}
   $$

   正如图1中描述的，根据限时可见，限时因果关系是比因果一致性更强的语义。类似的，限时串行一致性[Torres-Rojas and Meneses, [2005](#torresrojasandmeneses2005)]将真实时间全局顺序保障与限时可串行化约束结合在了一起。
   因此，一个$\Delta$=0的限时串行一致性执行，事实上就是可线性化。
   [Golab et al., [2011](#golabetal2011)]描述了$\Delta$原子性，它和限时一致性是完全相同的语义。也就是说，根据$\Delta$原子性，读操作要不返回之前最后一次写入的值，要不返回最多$\Delta$时间单位之前的写操作写入的值。
   在一项之后的工作中，[Golab et al., [2014](#golabetal2014)]提出了一种新颖的测量法$\Gamma$，该测量法前提假设更少，在时钟漂移的情况下也比$\Delta$更健壮。
   我们用如下谓词表达$\Delta$原子性，$\Gamma$原子性和限时串行一致性中的核心概念:

   $$
   \begin{equation}
   T_{IMED}L_{INEARIZABILITY}(\mathcal{F},\Delta) \triangleq S_{INGLE}O_{RDER} \land T_{IMED}V_{ISIBILITY}(\Delta) \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   图6阐明了一次进程A,B所见和固定时间参数$\Delta$有关的执行

   ![6](/assets/Consistency in Non-Transactional Distributed Storage Systems/figure 6.png)

   图6: 共享对象上执行操作

   如果无视时间参数的话，$P_{A}$和$P_{B}$会看到如下序列:

   $$
   \begin{equation}
   S_{P_{A,B}} : W_{2} \phantom{2} W_{6} \phantom{2} W_{1} \phantom{2} W_{3} \phantom{2} W_{4} \phantom{2} W_{5} \tag{S.10}
   \end{equation}
   $$

   如上执行满足顺序一致性，但却不满足显示串行一致性的需求。这也是图1中顺序一致性和限时串行一致性的联系所在。

   前缀一致性[Terry et al., [1995](#terryetal1995); Terry, [2013](#terry2013)], 也被称之为时间线一致性[Cooper et al., [2008](#cooperetal2008)], 赋予了消费者观察到有序写序列的保证，尽管序列中可能不包含最新的几次写操作。
   所以该一致性更多的约束了顺序，而非时效性: 读到的值一定是一次特定写序列的结果，该写序列的顺序被所有的副本所认可。该预先建立的顺序可能比顺序一致性要"旧"一些。因此，我们也可以将前缀一致性叫做前缀顺序一致性。
   如果在此基础上又满足实时性约束，则是前缀线性一致性。形式上，我们描述前缀顺序一致性:

   $$
   \begin{equation}
   P_{REFIX}S_{EQUENTIAL}(\mathcal{F}) \triangleq S_{INGLE}O_{RDER} \land M_{ONOTONIC}W_{RITES} \land RV_{AL}({F})
   \end{equation}
   $$

   其中单调写($M_{ONOTONIC}W_{RITES})保证了同一个会话中写操作的有序。类似的，我们定义前缀线性一致性:

   $$
   \begin{equation}
   P_{REFIX}L_{INEARIZABLE}(\mathcal({F}) \triangleq S_{INGLE}O_{RDER} \land R_{EAL}T_{IME}WW \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   其中

   $$
   \begin{equation}
   R_{EAL}T_{IME}WW \triangleq rb|_{wr \rightarrow wr} \subseteq ar
   \end{equation}
   $$

   在一项针对有恶意错误的基于法定票数的副本系统的研究中，Aiyer et al. [2005](#aliyeretal2005)将一种更为松散的，能容忍有限的基于版本的过时数据的语义形式化。
   实际上，K-safe, K-regular和K-atomic(或者叫K-linearizability)通过允许读取不重叠的写并发的最近K个值中的一个，概括了[Lamport, [1986a](#lamport1986a)]提出的寄存器一致性条件。
   比如，K-linearizability可以形式化为:

   $$
   \begin{equation}
   K-L_{INEARIZABLE}(\mathcal{F},\mathcal{K}) \triangleq S_{INGLE}O_{RDER} \land R_{EAL}T_{IME}WW \land K-R_{EAL}T_{IME}R_{EADS}(\mathcal{K}) \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   其中

   $$
   \begin{equation}
   K-R_{EAL}T_{IME}R_{EADS}(\mathcal{K}) \triangleq \forall a \in H|_{wr}, \forall b \in H|_{rd}, \forall PW \subseteq H|_{wr}, \forall_{pw} \in PW: \\
   |PW| \lt K \land a \xrightarrow{ar} pw \land pw \xrightarrow{rb} b \land a \xrightarrow{rb} b \implies a \xrightarrow{ar} b
   \end{equation}
   $$

   最后，Bailis et al., [2012](#bailisetal2012)在此基础上建立了一系列概率模型，来预测最终一致性，且基于投票的存储系统的读操作的过时性。
   他们提出了概率有限过时一致性(PBS, Probabilistically Bounded Staleness) **k-过时一致性**和PBS **t-可见性**。
   其中前者描述了用来限制读操作返回值过时性的概率模型，后者限制了一次写操作可见的时间。这两个模型的组合被称作**PBS<k,t>-staleness**。
   某种意义上说，**PBS k-过时一致性**是比**K-原子性**更弱的模型，换句话说，如果可能性为1的话，那么**k-过时一致性**就是**K-线性一致性**。
   类似的，**PBS t-可见性**比**限时可见性**要弱。

## 3.7 Fork-based模型

   鉴于对外部存储和计算的信任有限，[Cachin et al., [2009b](#cachinetal2009b); Vukolić, [2010](#vukolić2010)]修订了关于算法和协议的研究成果，用来处理拜占庭错误[Lamport et al., [1982](#lamportetal1982)]，即随意的，恶意的行为。
   在拜占庭错误模型中，错误的进程和共享对象可能会篡改数据，或者进行其他的随意的行为来故意破坏执行。

   在这些算法中，新的一致性模型被定义，以重塑在拜占庭错误前提下的正确性条件。在这些存储仓库不被信任的环境下，拜占庭错误容忍可以帮助我们屏蔽一些错误模式[Vukolić, [2010](#vukolić2010); Bessani et al., [2013](#bessanietal2013)]，
   甚至能实现强一致性语义(比如，线性一致性)[Bessani et al., [2014](#bessanietal2014); Dobre et al., [2014](#dobreetal2014)]。当处理单一的不被信任的存储仓库时，情况又有所不同。在这种情况下，一致性语义可以放宽松一些[Cachin et al., [2009b](#cachinetal2009b)]。
   我们将处理正确的客户端和不被信任的(拜占庭错误的)存储之间交互的可行的一致性方案囊括在了基于分支(fork-based)的一致性模型中。简单来说，当存储本身是正确的时候，系统可以提供线性一致性；当存储存在拜占庭式错误的时候，系统只能提供更弱的一致性模型，也就是fork-based一致性模型。

   这一簇一致性模型源于fork一致性(或者叫fork-线性一致性)，它由[Mazieres and Shasha [2002](#mazieresandshasha2002)]提出。简单来说，如果存储系统错误的造成了两个进程所见的操作不一致了(就算只有一次操作)，这两个进程再也不会观察到对方的写操作，而不是报错，
   那么我们说该系统保障了fork-线性一致性。特别的，不同进程组所观察到的任何分叉的历史，是能够被任何何用的通信协议轻松发现的(比如，带外通信，Gossip协议等等)。分支-线性一致性也遵循会话顺序(PRAM语义)和实时性仲裁，因此可以被表示为:

   $$
   \begin{equation}
   F_{ORK}L_{INEARIZABILITY}(\mathcal{F}) \triangleq PRAM \land R_{EAL}T_{IME} \land N_{O}J_{OIN} \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   其中$N_{O}J_{OIN}$谓词保证了已经在其他客户端上产生了分支的客户端所见的操作序列，不能被重新合并:

   $$
   \begin{equation}
   N_{O}J_{OIN} \triangleq \forall a_{i},b_{i},a_{j},b_{j} \in H : a_{i} \not\approx_{ss} a_{j} \land (a_{i},a_{j}) \in ar \setminus vis \land a_{i} \preceq_{so} b_{i} \land a_{j} \preceq_{so} b_{j} \implies (b_{i},b_{j}),(b_{j},b_{i}) \notin vis
   \end{equation}
   $$

   [Li and Mazieres, [2007](#liandmazieres)]随后提出了$fork^{\*}$一致性，使得该协议有更好的效率和活跃度。$Fork^{\*}$一致性比fork一致性更宽松，它允许分叉的进程看见最多一个公共的由正确的进程发起的执行。

   $$
   \begin{equation}
   F_{ORK}{^{*}}(\mathcal{F}) \triangleq R_{EAD}Y_{OUR}W_{RITES} \land R_{EAL}T_{IME} \land A_{T}M_{OST}O_{NE}J_{OIN} \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   其中

   $$
   \begin{equation}
   A_{T}M_{OST}O_{NE}J_{OIN} \triangleq \forall a_{i},a_{j} \in H : a_{i} \not\approx_{ss} a_{j} \land (a_{i},a_{j}) \in ar \setminus vis \implies \\
   \land |\{b_{i} \in H : a_{i} \preceq_{so} b_{i} \land (\exists b_{j} \in H : a_{j} \preceq_{so} b_{j} \land b_{i} \xrightarrow{vis} b_{j} \}| \le 1 \\
   \land |\{b_{j} \in H : a_{j} \preceq_{so} b_{j} \land (\exists b_{i} \in H : a_{i} \preceq_{so} b_{i} \land b_{j} \xrightarrow{vis} b_{i} \}| \le 1
   \end{equation}
   $$

   需要注意的是，$fork^{*}$并不能像$fork$-线性一致性那样保证单调读，因此也不能保证PRAM[Cachin et al., [2011](#cachinetal2011)]。

   Fork-顺序一致性[Oprea and Reiter, [2006](#opreaandreiter2006); Cachin et al., [2009a](#cachinetal2009a)]要求无论何时，当一个操作被多个进程所见时，所有这些进程看到的该操作之前的操作历史顺序必须相同。
   因此，当一个进程读到另个进程的某次写入的值的时候，我们就能确保该读进程和该写进程在本次写入之前有相同的历史。本质上，与顺序一致性类似，一旦某个操作全局可见了，那么它之前的操作一定存在一个全序。形式上：

   $$
   \begin{equation}
   F_{ORK}S_{EQUENTIAL}(\mathcal{F}) \triangleq PRAM \land N_{O}J_{OIN} \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   Mahajan et al. 定义了fork-join因果一致性(FJC)，这是因果一致性的更弱的版本，它可以在拜占庭错误发生的时候保证正确性和可用性[Mahajan et al., [2010](#mahajanetal2010)]。
   在fork-join因果一致性的存储系统中，如果一个正确的进程发起的一次写操作$op$依赖另一个进程的一次写操作$op'$，那么在任何正确的进程中，$op'$都在$op$之前可见。
   换句话说，FJC确保了正确进程中的因果一致性。另外，分组的进程是允许在合并规则下合并他们的历史的，因为拜占庭进程导致的不一致的写操作会被认为是多个虚拟进程的并发写。
   有界的fork-join因果一致性[Mahajan et al., [2011](#mahajanetal2011)]做了进一步的优化，它限制了一个错误的节点能产生的分支数，也因此限制了因此需要产生的虚拟节点的数量。

   最后，弱fork-线性一致性[Cachin et al., [2011](#cachinetal2011)]的弱，相比fork-线性一致性，提现在两个方面: 1、当产生分支时，两个进程可以多看见至多1次操作(就像$fork^*$系列一致性中的$最多一次join$);
   2、最后一次可见操作的实时顺序是不被保证的(就像$弱实时顺序$一样)。这两个条件使我们能设计出实时性更好的协议。弱fork-线性一致性可以被表达为:

   $$
   \begin{equation}
   W_{EAK}F_{ORK}L_{IN}(\mathcal{F}) \triangleq PRAM \land K-R_{EAL}T_{IME}(2) \land A_{T}M_{OST}O_{NE}J_{OIN} \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   其中$K-R_{EAL}T_{IME}(2)$谓词和公式(36)中定义的$k-R_{EAL}T_{IME}R_{EAD})2$相比，只是把范围扩大到了所有操作类型上($\forall op \in H)。
   需要注意的是，$弱fork-线性一致性$和$fork^{*}$一致性不具有可比性[[Cachin et al., 2011](#cachinetal2011)]。

## 3.8 复合和可调优的语义

   为了填补强一致性和他们的实现难度之间的沟壑，人们又提出了许多一致性模型，让使用者能够在不同的场景下再性能和正确性之间做出权衡。

   区分不同操作的不同一致性要求这个想法，可以追溯到共享内存系统的领域。
   在不同的操作之间会有不同顺序约束的一致性模型被称作**hybrid**，而那些约束相同的则称之为**uniform**[[Mosberger, 1993](#mosberger1993); [Dubois et al., 1986](#duboisetal1986); [Gharachorloo et al., 1990](#gharachorlooetal1990)]。

   第一个能表现这种多样性的形式化的定义，由[[Attiya and Friedman, 1992](#attiyaandfriedman1992)]为共享内存的多处理器提出的。**Hybrid**一致性被定义为一种弱一致性和强一致性的组合语义。
   在hybrid一致性系统中 强一致性操作能保证在所有进程中有全序(就像顺序一致性)，而弱一致性操作则性能更好，他们最终会在所有进程上可见(就像最终一致性)。
   弱一致性操作的顺序仅仅在他们和强一致性操作交替发生的时候才会有保障: 如果两个操作属于同一个会话，并且他们其中一个是强一致性，那么这两个操作的相对顺序在所有进程看来是一致的。
   在一个相似的方案中，[[Ladin et al., 1992](#ladinetal1992)]通过给每种操作指定一种顺序类型来处理性能和一致性之间的权衡问题。
   **Causal**操作会遵循因果顺序，**forced**操作则会有所有副本上的全序。

   **最终串行一致性**由[[Fekete et al., 1996](#feketeetal1996)]提出。它要求操作的偏序最终形成一个全序。根据这个模型，操作可能是**严格的**，也可能是**非严格的**。
   严格的操作在收到返回值之后就必须是**稳定的**，与之相对，非严格的操作则有可能被重新排序。如果一个操作是严格的，那么在它之前的所有操作一定已经达到了全局有序的状态。
   [[Fekete et al., 1996](#feketeetal1996)]设想的实现方案是，每个生成操作的进程都将需要在某操作之前保证有序的进程的唯一标识及操作类型(严格或非严格)记录下来。
   我们可以认为最终的全局顺序是一种不包含实时性要求的顺序一致性。

   类似的，[[Serafini et al., 2010](#serafinietal2010)]区分了强弱操作。其中，强操作会被立即线性化，弱操作会被最终线性化。我们也可以说弱操作符合最终线性一致性。
   弱操作实际上是被设计用于防止故意的错误的，也因此会在有限的时间段内违反线性一致性。本质上，最终线性一致性要求操作必须按照他们实时的顺序进行排序，所以操作只会在一段时间t后才生效。
   因此，更早的操作历史可能有不一致的情况，他们的顺序可能会暂时显得比较随机。最终，实现了最终线性一致性的系统中的操作会逐渐演进成全序，并遵循实时约束。

   [[Krishnamurthy et al., 2002](#krishnamurthyetal2002)]提出了QoS模型，它允许分布式存储系统的客户端提出自己的一致性要求。根据一致性要求的不同，客户端会被一个中间件重定向到副本集群中的不同组，这些组有些实现了强一致性，有些则是弱一致性。
   我们称这样的架构为可调优一致性。

   在同一脉络中，[[Li et al., 2012](#lietal2012)]提出了**红蓝**一致性。实现了红蓝一致性的操作会根据不同的条件，如他们的交换性和不变性被标记为蓝或者红。
   根据这样的分级，操作在本地执行之后，可能被按照最终一致性的方式通知给其他副本，也可能按照同步的方式串行通知给其他副本。
   [[Li et al., 2014](#lietal2014)]之后又实现并评估了一种通过提供自动组合和动态代码分析的功能，让程序员免于选择一致性级别的系统。

   [[Yu and Vahdat, 2002](#yuandvahdat2002)]基于三个指标: 过时性，顺序错误和数值错误提出了持续性一致性。
   这些指标被打包在一个我们称之为一致性单元(**conit**, consistency unit)的指标中，该指标是一个三维向量，它可以被用来衡量和理想的线性一致性执行之间的差异。数值错误统计了已经被认为全局执行了的，但是还没有被应用在某一个特定副本上的写操作的数量。
   顺序错误统计了在任意副本上有待被重新排序的写操作的数量。过时性则统计了副本上传播的写操作的延迟。这些指标是为了描绘一致性中的一些基础维度的语义而设立的，尤其是那些和状态、更新顺序等要求相关的语义。
   需要注意的是，根据这个模型，不像限时一致性(3.6中所介绍的)，时间相关的过时性是从副本的角度看的，而不是从独立的操作角度看的。

   相似的，[[Santos et al., 2007](#santosetal2007)]也用了一个三维的一致性向量来衡量副本中的数据对象的不一致。矢量场一致性最初是为了ad-hoc网络中分布式多人游戏而设计的。
   它要求每个对象有一个矢量$\mathcal{k} = [\theta,\sigma,\nu]$来描述过时性。特别的，向量通过时间($\theta$)，更新数量($\sigma$)，和对象值($\nu$)描绘了副本间的最大差异。
   与conit不同的是，该模型引进了本地感知的概念，这个概念将一致性描述为部署在整个游戏虚拟环境中的向量场。

   之后的工作推进了可调优一致性以适应云存储系统，这其中需要提供更为灵活的QoS策略和SLA。[[Kraska et al., 2009](#kraskaetal2009)]设想了一种定量分配的一致性，它会根据经济因素在运行时调整一致性级别。
   同样的，[[Chihoub et al., 2012](#chihoubetal2012)]也提供了一种自适应的协议来根据程序需要动态调整一致性级别。之后，[[Chihoub et al., 2013](#chihoubetal2013)]在公式中加入了钱的因素，并研究了它与一致性在云存储中的权衡问题。
   [[Terry et al., 2013](#terryetal2013)]提倡使用声明式的基于一致性的SLA，来让云键值存储系统的使用者更好的感知性能-正确性之间的权衡问题。这篇文章随后被[[Sivaramakrishnan et al., 2015](#sivaramakrishnanetal2015)]实现为了一种声明式的编程模型。

   在另一种为geo-副本存储提供强一致性语义的尝试中，[[Balegas et al., 2015](#balegasetal2015)]引入了**显示**一致性。一个实现了显示一致性的副本存储系统，除了能提供最终一致性之外，还能够确保执行过程中的应用级别的正确性要求(也就是，不变性)。
   在后续的工作中，[[Gotsman et al., 2016](#gotsmanetal2016)]提出了一种证明原则，来帮助程序员在处理被精心设定了限制的操作时能保证数据完整性。

   最后，在结合不同一致性模型时，值得指出的是，有些系统能依据当前系统的元数据和已经保证线性一致性的数据相比较，将最终一致性的数据(大部分商用的存储系统提供的)转化为线性一致性的数据。
   在另一份独立的工作中，这种技术被表述为一致性锚点[[Bessani et al., 2014](#bessanietal2014)]和一致性强化[[Dobre et al., 2014](#dobreetal2014)]。

## 3.9 基于对象的语义

   基于对象(或者说基于键)的语义是用来表述每个对象上的一致性约束的。直观上，基于对象的顺序语义支持一些相比全局顺序来说更为效率的实现，也能更好的利用诸如分片和状态分割技术。

   慢内存，由[[Hutto and Ahamad, 1990](#huttoandahamad1990)]定义，是PRAM一致性的一个更弱的版本。一个实现了该条件的共享内存系统中，一个给定进程给一个给定的对象的写操作，在所有进程看来都有着相同的顺序。
   换句话说，慢内存描绘了一种基于对象的PRAM一致性的弱化版本:

   $$
   \begin{equation}
   P_{ER}O_{BJECT}PRAM \triangleq (so \cap ob) \subseteq vis
   \end{equation}
   $$

   这一簇一致性语义中的一个重要概念是**coherence**【译者注：coherence中文也称之为一致性，但是在此处上下文中，更多的事指多级内存之间的一致性，为了和consistency区别开，故此处沿用了原文中的coherence表述】
   [[Gharachorloo et al., 1990](#gharachorlooetal1990)](或者叫缓存一致性[[Goodman, 1989](#goodman1989)])，它最初是被用来描述共享内存多处理器系统[[Dubois et al., 1986](#duboisetal1986)]中的分级内存的正确性条件的。
   Coherence确保了对于某一内存位置的写操作对于所有处理器来说都是以同样的顺序被看见的，很大可能是通过处理器的本地缓存读取。换句话说，coherence要求基于对象的操作有全局顺序。
   [[Cooper et al., 2008](#cooperetal2008)]提出了一个类似的概念: 基于记录的时间轴一致性。该概念确保了在副本存储系统中，对于每个独立的键(对象)，每个进程观察到的操作顺序都相同。
   形式上，我们可以表述为:

   $$
   \begin{equation}
   P_{ER}O_{BJECT}S_{INGLE}O_{RDER} \triangleq \exists H' \subseteq {op \in H: op.oval = \nabla} : ar \cap ob = vis \cap ob \setminus (H' \times H)
   \end{equation}
   $$

   此外，如果一个系统中的执行满足一个进程对每个对象的操作全局有序，并且每个对象上的所有操作都全局有序，我们说该系统实现了基于对象的顺序(**per-object sequential**)一致性:

   $$
   \begin{equation}
   P_{ER}O_{BJECT}S_{EQUENTIAL}(\mathcal{F}) \triangleq P_{ER}O_{BJECT}S_{INGLE}O_{RDER} \land P_{ER}O_{BJECT}PRAM \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   处理器一致性，由[[Goodman, 1989](#goodman1989)]定义，并由[[Ahamad et al., 1993](#ahamadetal1993)]形式化，由两个条件构成: (a) 一个进程产生的写操作被观察到的顺序应该和他们产生的顺序一致，
   (b) 如果一个对象上有两个写操作，那么所有进程观察到的这两个写操作的顺序都相同。显然，这两个条件就是我们讲过的PRAM一致性和基于记录的时间轴一致性，因此:

   $$
   \begin{equation}
   P_{ROCESSOR}C_{ONSISTENCY}(\mathcal{F}) \triangleq P_{ER}O_{BJECT}S_{INGLE}O_{RDER} \land PRAM \land RV_{AL}(\mathcal{F})
   \end{equation}
   $$

   此外，一些文献(比如，[[Moraru et al., 2013](#moraruetal2013)])提到了对象线性一致性，其实就是从单个对象角度出发，根据**locality property**[[Herlihy and Wing, 1990](#herlihyandwing1990)]的线性一致性。

   我们注意到大家可以通过优化上文提到的谓词，来组成任意的一致性模型。比如[[Burckhardt et al., 2014](#burckhardtetal2014)]描述了对象因果一致性，它融合了对象上的**happens-before**关系，定义为:
   $hbo \triangleq ((so \cap ob) \cup vis)^{+}$

## 3.10 同步模型

   为了更加完善，这一章我们将概述80年和90年代初的一些用来在多核处理器共享内存系统上描述正确性的语义。为了实现这些系统的并行计算，也为了能处理不同部件(如内存，网络连接，处理器等等)之间的性能差异，缓冲区和缓存层被设计出来。
   因此，以此为基础架构的系统的都需要保证所有内存都能映射成一个公共的，一致的共享对象上。因此，系统的设计者们使用了同步变量，也就是一种只暴露出两种操作: **acquire**和**release**的对象。
   同步变量被用来当做一个通用抽象来实现控制共享对象的并发访问的。换句话说，同步变量通过诸如低级别的基元(如锁)或者高级别的编程语言结构体(如临界区)实现的互斥来保护对共享对象的访问。
   与其把使用这些工具的弊端留给开发者，系统应该能够区分对共享对象的访问和对同步变量的访问。这一般是通过暴露一个低等级的指令来实现。

   顺序一致性[[Lamport, 1979](#lamport1979)](我们在第3.3章节中定义的)起初是作为多处理器上的共享内存系统的理想正确性条件被提出的。
   [[Dubois et al., 1986](#duboisetal1986)]提出的弱排序一致性是一种性能更好的，也更方便的顺序一致性的弱化版本。[一些文献中也把若排序一致性称之为"弱一致性"，我们为了避免二义性而选择了他最初的命名]
   如果一个系统实现了弱排序一致性: (a)所有访问同步变量的操作必须是强排序的，(b)如果同步变量上之前的读请求还未结束，该同步变量不允许被访问，(c)进程在访问同步变量之前不允许进行任何的读操作。
   特别的，[[Dubois et al, 1986](#duboisetal1986)]定义操作是强排序的，当操作满足两个条件:操作必须按照他们的会话顺序排序，不同会话操作的相对顺序则按照管道化的基于缓存的系统支持的某些特殊指令进行排序。
   弱排序一致性后来又被重新定义，来处理软件和硬件的交互问题。[[Adve and Hill, 1990](#adveandhill1990)]定义同步模型为内存访问的一系列约束，这些约束决定了合适需要同步，怎样进行同步。
   定义如下，"一个硬件满足一种给定的同步模型的弱排序一致性，当且仅当它对于所有遵循该同步模型的软件是顺序一致的。"

   **Release**一致性，由[[Gharachorloo et al., 2990](#gharachorlooetal1990)]提出，是弱排序一致性的更弱的扩展。它利用了同步操作(acquire和release)的一些更详细的信息和非同步的访问。
   操作在执行之前会被打上强弱标签。因此，Release一致性其实拓宽了弱排序一致性的边界，弱排序一致性只有同步和非同步标签。类似于混合一致性(见3.8章)，强操作是依据处理器或者顺序一致性排序的，而弱操作只需要保持和处于同一个进程的强操作的相对顺序即可。

   随后，许多算法都对release一致性做了细微的调整。比如**lazy release**一致性[[Keleher et al., 1992](#keleheretal1992)]，它的一致性保障由操作执行的时间点推迟到了下一次acquire操作的时间点。lazy release一致性的原理是去减少分布式共享内存系统的消息数和数据交换量。
   类似的，一种叫做**automatic update release**一致性[[Iftode et al., 1996a](#iftodeetal1996a)]的协议则试图通过一种在虚拟内存映射网络接口上提供的自动更新的机制来提升纯软件实现的**lazy release**一致性的性能问题。

   [[Bershad and Zekauskas, 1991](#bershadandzekauskas1991)]定义了**entry**一致性，它强化了同步对象和他们所保护的数据之间的关联。根据**entry**一致性，所有对象都需要被同步变量保护起来。因此，在某种意义上，这种模型在一致性关系图上是更弱的。
   此外，entry一致性也能进一步区分排他操作和飞排他操作。正是因为有了这些功能，读操作才能有更好的并发性，也因此性能更佳。

   **Scope**一致性[[Iftode et al., 1996b](#iftodeetal1996b)]声称可以提供所有entry一致性能提供的性能优势，并且不需要显示的将数据绑定在同步变量上。
   scope一致性的关键点就是使用了使用了**scope**的抽象来隐式的获取数据和同步操作之间的关系。一致性scope可以自动从程序的同步变量中继承而来，这大大的简化了程序员的工作。

   根据**location**一致性的定义，[[Gao and Sarkar, 2000](#gaoandsarkar2000)]摒弃了内存coherence[[Gharachorloo et al., 1990](#gharachorlooetal1990)]，也就是保证所有对于同一个对象的写操作都被所有进程以同样的顺序看见的属性(见3.9章)。
   这种一致性仅要求了共享对象上写操作的偏序，因此，它提供了多线程程序正确执行的一种可能性。和entry一致性类似，在location一致性下，对象也和同步变量绑定在一起。
   然而，正是因为顺序要求上更加宽松，[[Gao and Sarkar, 2000](#gaoandsarkar2000)]证明了location一致性在数据关联性更低的程序中可以更加效率，并且能提供同等的一致性强度。

# 4 相关工作

   许多相关文献都概述过一致性模型的。在这一章节中，我们将根据这些文献的观点将他们进行分类。

   **共享内存系统** [[Gharachorloo et al. 1990](#gharachorlooetal1990)]提出了如何分级共享内存访问策略，特别是考虑到他们的并发控制语义(比如，同步操作vs读写访问)。
   [[Mosberger, 1993](#mosberger1993)]采用这个分类法，并研究了当时流行的一些内存一致性模型，和他们实现过程中的一些权衡问题。
   [[Adve and Gharachorloo, 1996](#adveandgharachorloo1996)]用实用性指导的方式总结了共享内存多处理器系统中所采取的一致性模型的非正式定义和相关问题。

   后续的一些工作开发了统一的框架和符号去描述文献中[[Adve and Hill, 1993](#adveandhill1993); [Raynal and Schiper, 1997](#raynalandschiper1997); [Bataller and Bernabéu-Aubán, 1997](#batallerandbernabéuaubán1997)]定义的一致性语义。
   最值得注意的是，[[Steinke and Nutt, 2004](#steinkeandnutt2004)]基于一些基础声明式属性的组合，为共享内存系统提供的一套统一的一致性模型理论。这中声明式的和组合的方式，反过来由描绘出一种一致性语义中的偏序。
   [[Friedman et al., 2003](#friedmanetal2003)]也提出了一种相似的对于一致性条件的组合处理方式。

   尽管这些工作都有自己的价值，但是他们都只代表了现代非事务型的存储系统的一致性语义中有限的部分。

   **分布式存储系统** 在近几年，研究者提出了关于现代存储系统中的一些有效的一致性语义的分类。
   [[Tanenbaum and van Steen, 2007](#tanenbaumandvansteen2007)]提出了客户端为中心vs数据为中心的分类法，而[[Bermbach and Kuhlenkamp, 2013](#bermbachandkuhlenkamp2013)]扩展了该分类法，并增加了对于大多数流行模型的描述。
   尽管这些工作都试图让人们更好的理解一致性语义，但它们基于二分法的做法势必会遗漏掉一些一致性语义中重要的内容。我们的这篇论文基于这些工作，并采用了基于一阶逻辑和图论的形式化的模型，进一步完善了之前的理论。
   我们的工作基于[[Burckhardt, 2014](#burckhardt2014)]，并通过修正和扩展，描绘了更加宽广和丰富的一致性语义。此外，[[Burckhardt, 2014](#burckhardt2014)]只聚焦在了会话语义和最终一致性语义，我们的工作却包含了50多种不同的一致性语义。

   **度量一致性语义** 另一派研究为共享内存和分布式存储系统设计了统一的，严格的衡量一致性的框架。
   其中一些工作提出了衡量一致性的指标[[Yu and Vahdat, 2002](#yuandvahdat2002); [Golab et al., 2014](#golabetal2014)]，
   另一些工作设计出了方法来执行并证明一个系统是否符合一个特定的一致性模型[[Misra, 1986](#misra1986); [Gibbons and Korach, 1997](#gibbonsanddorach1997); [Anderson et al., 2010](#andersonetal2010)]。
   最后，鉴于最终一致性不严格的定义和不透明的实现，近期的一些工作试图从客户端感知的角度来量化与之而来的异常现象
   [[Wada et al., 2011](#wadaetal2011); [Patil et al., 2011](#patiletal2011); [Bermbach and Tai, 2011](#bermbachandtai2011); [Rahman et al., 2012](#rahmanetal2012); [Lu et al., 2015](#luetal2015)]。
   就这一点而言，我们的工作提供了一种更综合，也更结构化的指标，来衡量一致性。

   **事务型系统** 关注事务型系统中重要一致性模型的形式化的读者，可以参考[[Adya, 1999](#adya1999)]。类似的，[[Harris et al, 2010](#harrisetal2010)]和[[Dziuma et al, 2014](#dziumaetal2014)]完善了事务型内存系统的模型概述。
   最后，最近的一些研究[[Burckhardt et al., 2012](#burckhardtetal2012); [Cerone et al., 2015](#ceroneetal2015)]采取了和这篇论文中一样的架构提出了对于事务型一致性模型的公理式的说明。

# 5 总结

   在这篇论文中，我们呈现了与非事务型存储系统相关的一致性模型的概览。得益于我们按部就班的工作，我们能够描述出一致性模型之间微妙的却又富有意义的区别，进而帮助学者们和从业者们更好的理解。

   为了描述一致性语义，我们引入了图论和一阶逻辑。作为本论文的第一个贡献，我们基于[[Burckhardt, 2014](#burckhardt2014)]创造了形式化的架构。该架构有很强的综合性，对于描述分布式存储系统执行过程中的各种因子也十分有用。

   我们使用这套框架正式的形式化描述了50多种一致性语义。对于其他的一些语义，我们也提供了非形式化的描述，以提供对于他们功能和一致性相对强弱的概览。此外，得益于我们采取的公理式的方法，我们根据特性和共性陈列出了一群语义。
   反过来，语义的聚类和形式化都帮助我们建立了一致性模型的偏序(见图1)。我们相信该偏序不仅能够使设计精确，连贯的模型变得更加便利，也能够让对于现有系统正确性的衡量和比较更加便利。
   最后，为了下一步的贡献，我们在附录B中提供了本文中所有分析过的模型的顺序列表，同时提供了他们的定义和大部分实现的参考资料和参考文献。

# 致谢

   我们在此感谢Alysson Bessani, Christian Cachin, Marc Shapiro, 和其他匿名人士对于本论文的建议。EU projects CloudSpaces(FP7-317555)和SUPERCLOUD(Horizon 2020 programme, grant No. 643964)部分支持了该项研究工作。

# 引用文献

<a id="leslielamport1978">
* Leslie Lamport. 1978. Time, Clocks, and the Ordering of Events in a Distributed System.
  Communications of the ACM (CACM) 21, 7 (1978), 558–565.

<a id="leslielamport1986a">
* Leslie Lamport. 1986a. On Interprocess Communication. Part I: Basic Formalism. Distributed
  Computing 1, 2 (1986), 77–85.

<a id="herlihyandwing1990">
* Maurice Herlihy and Jeannette M. Wing. 1990. Linearizability: A Correctness Condition for
  Concurrent Objects. ACM Transactions on Programming Languages and Systems (TOPLAS)
  12, 3 (1990), 463–492.

<a id="fischeretal1985">
* Michael J. Fischer, Nancy A. Lynch, and Mike Paterson. 1985. Impossibility of Distributed
  Consensus with One Faulty Process. J. ACM 32, 2 (1985), 374–382. DOI:http://dx.
  doi.org/10.1145/3149.214121

<a id="gilbertandlynch2002">
* Seth Gilbert and Nancy A. Lynch. 2002. Brewer’s conjecture and the feasibility of consistent,
  available, partition-tolerant web services. SIGACT News 33, 2 (2002), 51–59.

<a id="terryetal1994">
* Douglas B. Terry, Alan J. Demers, Karin Petersen, Mike Spreitzer, Marvin Theimer, and Brent B.
  Welch. 1994. Session Guarantees for Weakly Consistent Replicated Data. In Parallel and
  Distributed Information Systems (PDIS). 140–149.

<a id="saitoandshapiro2005">
* Yasushi Saito and Marc Shapiro. 2005. Optimistic replication. Comput. Surveys 37, 1 (2005),
  42–81.

<a id="vogels2008">
* Werner Vogels. 2008. Eventually Consistent. Queue 6, 6 (Oct. 2008), 14–19. DOI:http:
  //dx.doi.org/10.1145/1466443.1466448

<a id="bailisandghodsi2013">
* Peter Bailis and Ali Ghodsi. 2013. Eventual Consistency Today: Limitations, Extensions,
  and Beyond. Queue 11, 3 (March 2013), 20:20–20:32. DOI:http://dx.doi.org/10.
  1145/2460276.2462076

<a id="bailisetal2014">
* Peter Bailis, Alan Fekete, Joseph M. Hellerstein, Ali Ghodsi, and Ion Stoica. 2014. Scalable
  atomic visibility with RAMP transactions. In ACM International Conference on Management
  of Data (SIGMOD), 2014. 27–38. DOI:http://dx.doi.org/10.1145/2588555.
  2588562

<a id="helland2007">
* Pat Helland. 2007. Life beyond Distributed Transactions: an Apostate’s Opinion. In Conference
  on Innovative Data Systems Research (CIDR), 2007. 132–141. http://www.cidrdb.
  org/cidr2007/papers/cidr07p15.pdf

<a id="alvaroetal2011">
* Peter Alvaro, Neil Conway, Joseph M. Hellerstein, and William R. Marczak. 2011. Consistency
  Analysis in Bloom: a CALM and Collected Approach. In Conference on Innovative Data
  Systems Research (CIDR), 2011. 249–260. http://www.cidrdb.org/cidr2011/
  Papers/CIDR11_Paper35.pdf

<a id="shapiroetal2011a">
* Marc Shapiro, Nuno M. Preguic¸a, Carlos Baquero, and Marek Zawirski. 2011a. Conflict-Free
  Replicated Data Types. In Stabilization, Safety, and Security of Distributed Systems (SSS), 2011. 386–400. DOI:http://dx.doi.org/10.1007/978-3-642-24550-3_29

<a id="burckhardtetal2012">
* Sebastian Burckhardt, Manuel Fahndrich, Daan Leijen, and Benjamin P. Wood. 2012. Cloud ¨
  Types for Eventual Consistency. In Object-Oriented Programming (ECOOP), 2012. 283–307.
  DOI:http://dx.doi.org/10.1007/978-3-642-31057-7_14

<a id="alvaroetal2014">
* Peter Alvaro, Neil Conway, Joseph M. Hellerstein, and David Maier. 2014. Blazes: Coordination
  analysis for distributed programs. In IEEE Conference on Data Engineering (ICDE), 2014.
  52–63. DOI:http://dx.doi.org/10.1109/ICDE.2014.6816639

<a id="adya1999">
* Atul Adya. 1999. Weak Consistency: A Generalized Theory and Optimistic Implementations
  for Distributed Transactions. Ph.D. MIT, Cambridge, MA, USA. Also as Technical Report
  MIT/LCS/TR-786.

<a id="burckhardt2014">
* Sebastian Burckhardt. 2014. Principles of Eventual Consistency. Foundations and Trends in
  Programming Languages, Vol. 1. now publishers. 1–150 pages. http://research.
  microsoft.com/apps/pubs/default.aspx?id=230852

<a id="lynchandtuttle1989">
* Nancy A. Lynch and Mark R. Tuttle. 1989. An introduction to input/output automata. CWI
  Quarterly 2 (1989), 219–246.

<a id="herlihyandwing1990">
* Maurice Herlihy and Jeannette M. Wing. 1990. Linearizability: A Correctness Condition for
  Concurrent Objects. ACM Transactions on Programming Languages and Systems (TOPLAS)
  12, 3 (1990), 463–492.

<a id="lynchandtuttle1989">
* Nancy A. Lynch and Mark R. Tuttle. 1989. An introduction to input/output automata. CWI
  Quarterly 2 (1989), 219–246.

<a id="birmanetal1991">
* Kenneth Birman, Andre Schiper, and Pat Stephenson. 1991. Lightweight causal and atomic group
  multicast. ACM Transactions on Computer Systems (TOCS) 9, 3 (1991), 272–314.

<a id="hardzilacosandtoueg1994">
* Vassos Hadzilacos and Sam Toueg. 1994. A modular approach to fault-tolerant broadcasts and
  related problems. Technical Report. Cornell University, Department of Computer Science.

<a id="lamport2001">
* Leslie Lamport. 2001. Paxos Made Simple. SIGACT News 32, 4 (2001), 51–58. DOI:http:
  //dx.doi.org/10.1145/568425.568433

<a id="johnsonandrobert1975">
* Paul R. Johnson and Robert H. Thomas. 1975. Maintenance of duplicate databases. RFC 677. RFC Editor. http://www.rfc-editor.org/rfc/rfc677.txt http://
  www.rfc-editor.org/rfc/rfc677.txt.

<a id="davidsonetal1985">
* Susan B. Davidson, Hector Garcia-Molina, and Dale Skeen. 1985. Consistency in Partitioned
  Networks. Comput. Surveys 17, 3 (1985), 341–370.

<a id="coanetal">
* Brian A. Coan, Brian M. Oki, and Elliot K. Kolodner. 1986. Limitations on Database Availability
  when Networks Partition. In ACM Symposium on Principles of Distributed Computing, 1986.
  187–194. DOI:http://dx.doi.org/10.1145/10590.10606

<a id="brewer2000">
* Eric A. Brewer. 2000. Towards robust distributed systems (abstract). In ACM Symposium on
  Principles of Distributed Computing (PODC), 2000. 7. DOI:http://dx.doi.org/10.
  1145/343477.343502

<a id="lamport1986b">
* Leslie Lamport. 1986b. On Interprocess Communication. Part II: Algorithms. Distributed
  Computing 1, 2 (1986), 86–101.

<a id="bermbachandkuhlenkamp2013">
* David Bermbach and Jorn Kuhlenkamp. 2013. Consistency in Distributed Storage Systems - An
  Overview of Models, Metrics and Measurement Approaches. In Networked Systems (NETYS), 2013. 175–189.

<a id="bermbachandtai2011">
* David Bermbach and Stefan Tai. 2011. Eventual Consistency: How Soon is Eventual? An
  Evaluation of Amazon S3’s Consistency Behavior. In Workshop on Middleware for Service
  Oriented Computing (MW4SOC ’11). ACM, New York, NY, USA, 1:1–1:6. DOI:http:
  //dx.doi.org/10.1145/2093185.2093186

<a id="bernsteinanddas2013">
* Philip A. Bernstein and Sudipto Das. 2013. Rethinking eventual consistency. In ACM SIGMOD
  International Conference on Management of Data (SIGMOD), 2013. 923–928. DOI:http:
  //dx.doi.org/10.1145/2463676.2465339

<a id="herlihyandshavit2008">
* Maurice Herlihy and Nir Shavit. 2008. The art of multiprocessor programming. Morgan
  Kaufmann. I–XX, 1–508 pages.

<a id="liptonandsandberg1988">
* Richard J. Lipton and Jonathan S. Sandberg. 1988. PRAM: A scalable shared memory. Technical
  Report CS-TR-180-88. Princeton University.

<a id="lamport1979">
* Leslie Lamport. 1979. How to Make a Multiprocessor Computer That Correctly Executes
  Multiprocess Programs. IEEE Trans. Comput. 28, 9 (1979), 690–691.

<a id="tanenbaumandvansteen2007">
* Andrew S. Tanenbaum and Maarten van Steen. 2007. Distributed systems - principles and
  paradigms (2. ed.). Pearson Education. I–XVIII, 1–686 pages.

<a id="terryetal2013">
* Douglas B. Terry, Vijayan Prabhakaran, Ramakrishna Kotla, Mahesh Balakrishnan, Marcos K.
  Aguilera, and Hussam Abu-Libdeh. 2013. Consistency-based service level agreements for
  cloud storage. In ACM Symposium on Operating Systems Principles (SOSP), 2013. 309–324.

<a id="huttoandahamad1990">
* Phillip W. Hutto and Mustaque Ahamad. 1990. Slow Memory: Weakening Consistency to
  Enchance Concurrency in Distributed Shared Memories. In International Conference on
  Distributed Computing Systems (ICDCS). 302–309.

<a id="ahamadetal1995">
* Mustaque Ahamad, Gil Neiger, James E. Burns, Prince Kohli, and Phillip W. Hutto. 1995. Causal
  Memory: Definitions, Implementation, and Programming. Distributed Computing 9, 1 (1995),
  37–49.

<a id="mahajanetal2011">
* Prince Mahajan, Lorenzo Alvisi, and Mike Dahlin. 2011. Consistency, availability, and convergence. Technical Report TR-11-22. Computer Science Department, University of Texas at
  Austin.

<a id="bailis2012">
* Peter Bailis, Alan Fekete, Ali Ghodsi, Joseph M. Hellerstein, and Ion Stoica. 2012. The potential
  dangers of causal consistency and an explicit solution. In ACM Symposium on Cloud Computing
  (SOCC), 2012. 22. DOI:http://dx.doi.org/10.1145/2391229.2391251

<a id="lloydetal2011">
* Wyatt Lloyd, Michael J. Freedman, Michael Kaminsky, and David G. Andersen. 2011. Don’t
  settle for eventual: scalable causal consistency for wide-area storage with COPS. In ACM
  Symposium on Operating Systems Principles (SOSP). 401–416.

<a id="bailisetal2013">
* Peter Bailis, Ali Ghodsi, Joseph M. Hellerstein, and Ion Stoica. 2013. Bolt-on causal consistency.
  In ACM SIGMOD International Conference on Management of Data (SIGMOD), 2013. 761–
  772.

<a id="zawirskietal2015">
* Marek Zawirski, Nuno Preguic¸a, Sergio Duarte, Annette Bieniusa, Valter Balegas, and Marc ´
  Shapiro. 2015. Write Fast, Read in the Past: Causal Consistency for Client-side Applications.
  ACM/IFIP/USENIX Middleware Conference, 2015.

<a id="attiyaetal2015">
* Hagit Attiya, Faith Ellen, and Adam Morrison. 2015. Limitations of Highly-Available EventuallyConsistent Data Stores.
  In ACM Symposium on Principles of Distributed Computing (PODC), 2015. ACM, Donostia-San Sebastian, Spain, 385–394. DOI:http://dx.doi.org/10.
  1145/2767386.2767419

<a id="torresrojasetal1999">
* Francisco J. Torres-Rojas, Mustaque Ahamad, and Michel Raynal. 1999. Timed Consistency
  for Shared Distributed Objects. In ACM Symposium on Principles of Distributed Computing
  (PODC), 1999. 163–172.

<a id="mahajanetal2010">
* Prince Mahajan, Srinath T. V. Setty, Sangmin Lee, Allen Clement, Lorenzo Alvisi, Michael
  Dahlin, and Michael Walfish. 2010. Depot: Cloud Storage with Minimal Trust. In Symposium
  on Operating Systems Design and Implementation (OSDI), 2010. 307–322.

<a id="torresrojasandmeneses2005">
* Francisco J. Torres-Rojas and Esteban Meneses. 2005. Convergence Through a Weak Consistency
  Model: Timed Causal Consistency. CLEI electronic journal 8, 2 (2005).

<a id="golabetal2011">
* Wojciech M. Golab, Xiaozhou Li, and Mehul A. Shah. 2011. Analyzing consistency properties
  for fun and profit. In ACM Symposium on Principles of Distributed Computing (PODC), 2011.
  197–206.

<a id="golabetal2014">
* Wojciech M. Golab, Muntasir Raihan Rahman, Alvin AuYoung, Kimberly Keeton, and Indranil
  Gupta. 2014. Client-Centric Benchmarking of Eventual Consistency for Cloud Storage Systems.
  In IEEE Conference on Distributed Computing Systems (ICDCS), 2014. 493–502. DOI:
  http://dx.doi.org/10.1109/ICDCS.2014.57

<a id="terryetal1995">
* Douglas B. Terry, Marvin Theimer, Karin Petersen, Alan J. Demers, Mike Spreitzer, and Carl
  Hauser. 1995. Managing Update Conflicts in Bayou, a Weakly Connected Replicated Storage
  System. In ACM Symposium on Operating Systems Principles (SOSP), 1995. 172–183. DOI:
  http://dx.doi.org/10.1145/224056.224070

<a id="terry2013">
* Doug Terry. 2013. Replicated data consistency explained through baseball. Communications of
  the ACM (CACM) 56, 12 (2013), 82–89.

<a id="cooperetal2008">
* Brian F. Cooper, Raghu Ramakrishnan, Utkarsh Srivastava, Adam Silberstein, Philip Bohannon,
  Hans-Arno Jacobsen, Nick Puz, Daniel Weaver, and Ramana Yerneni. 2008. PNUTS: Yahoo!’s
  hosted data serving platform. VLDB 1, 2 (2008), 1277–1288.

<a id="cachinetal2009b">
* Christian Cachin, Idit Keidar, and Alexander Shraer. 2009b. Trusting the cloud. SIGACT News
  40, 2 (2009), 81–86. DOI:http://dx.doi.org/10.1145/1556154.1556173

<a id="vukolić2010">
* Marko Vukolić. 2010. The Byzantine Empire in the Intercloud. SIGACT News 41, 3 (Sept. 2010),
  105–111. DOI:http://dx.doi.org/10.1145/1855118.1855137

<a id="lamportetal1982">
* Leslie Lamport, Robert E. Shostak, and Marshall C. Pease. 1982. The Byzantine Generals
  Problem. ACM Transactions on Programming Languages and Systems (TOPLAS) 4, 3 (1982),
  382–401. DOI:http://dx.doi.org/10.1145/357172.357176

<a id="bessanietal2013">
* Alysson Neves Bessani, Miguel Correia, Bruno Quaresma, Fernando Andre, and Paulo Sousa. 2013. DepSky: Dependable and Secure Storage in a Cloud-of-Clouds. ACM Transactions on
  Storage (TOS) 9, 4 (2013), 12. DOI:http://dx.doi.org/10.1145/2535929

<a id="bessanietal2014">
* Alysson Neves Bessani, Ricardo Mendes, Tiago Oliveira, Nuno Ferreira Neves, Miguel Correia,
  Marcelo Pasin, and Paulo Ver´ıssimo. 2014. SCFS: A Shared Cloud-backed File System. In
  USENIX Annual Technical Conference (ATC), 2014. 169–180. https://www.usenix.
  org/conference/atc14/technical-sessions/presentation/bessani

<a id="dobreetal2014">
* Dan Dobre, Paolo Viotti, and Marko Vukolic. 2014. Hybris: Robust Hybrid Cloud Storage. In ´
  ACM Symposium on Cloud Computing (SOCC), 2014. 12:1–12:14. DOI:http://dx.doi.
  org/10.1145/2670979.2670991

<a id="mazieresandshasha2002">
* David Mazieres and Dennis Shasha. 2002. Building Secure File Systems out of Byzantine Storage. `
  In ACM Symposium on Principles of Distributed Computing (PODC), 2002. 108–117.

<a id="cachinetal2011">
* Christian Cachin, Idit Keidar, and Alexander Shraer. 2011. Fail-Aware Untrusted Storage. SIAM
  Journal on Computing (SICOMP) 40, 2 (2011), 493–533. DOI:http://dx.doi.org/
  10.1137/090751062

<a id="opreaandreiter2006">
* Alina Oprea and Michael K. Reiter. 2006. On Consistency of Encrypted Files. In Distributed
  Computing (DISC), 2006. 254–268.

<a id="cachinetal2009a">
* Christian Cachin, Idit Keidar, and Alexander Shraer. 2009a. Fork Sequential Consistency is
  Blocking. Inform. Process. Lett. 109, 7 (2009), 360–364.

<a id="mosberger1993">
* David Mosberger. 1993. Memory Consistency Models. Operating Systems Review 27, 1 (1993),
  18–26. DOI:http://dx.doi.org/10.1145/160551.160553

<a id="duboisetal1986">
* Michel Dubois, Christoph Scheurich, and Faye A. Briggs. 1986. Memory Access Buffering in
  Multiprocessors. In International Symposium on Computer Architecture (ISCA). 434–442.

<a id="gharachorlooetal1990">
* Kourosh Gharachorloo, Daniel Lenoski, James Laudon, Phillip B. Gibbons, Anoop Gupta, and
  John L. Hennessy. 1990. Memory Consistency and Event Ordering in Scalable Shared-Memory
  Multiprocessors. In International Symposium on Computer Architecture. 15–26.

<a id="ladinetal1992">
* Rivka Ladin, Barbara Liskov, Liuba Shrira, and Sanjay Ghemawat. 1992. Providing High
  Availability Using Lazy Replication. ACM Transactions on Computer Systems (TOCS) 10, 4
  (1992), 360–391. DOI:http://dx.doi.org/10.1145/138873.138877

<a id="feketeetal1996">
* Alan Fekete, David Gupta, Victor Luchangco, Nancy A. Lynch, and Alexander A. Shvartsman. 1996. Eventually-Serializable Data Services. In ACM Symposium on Principles of Distributed
  Computing, 1996. 300–309. DOI:http://dx.doi.org/10.1145/248052.248113

<a id="serafinietal2010">
* Marco Serafini, Dan Dobre, Matthias Majuntke, Peter Bokor, and Neeraj Suri. 2010. Eventually ´
  Linearizable Shared Objects. In ACM Symposium on Principles of Distributed Computing
  (PODC), 2010. 95–104.

<a id="krishnamurthyetal2002">
* Sudha Krishnamurthy, William H. Sanders, and Michel Cukier. 2002. An Adaptive Framework for
  Tunable Consistency and Timeliness Using Replication. In Dependable Systems and Networks
  (DSN), 2002. 17–26.

<a id="lietal2012">
* Cheng Li, Daniel Porto, Allen Clement, Johannes Gehrke, Nuno Preguic¸a, and Rodrigo Rodrigues. 2012. Making Geo-replicated Systems Fast As Possible, Consistent when Necessary. In
  Symposium on Operating Systems Design and Implementation (OSDI), 2012 (OSDI’12).
  USENIX Association, Berkeley, CA, USA, 265–278. http://dl.acm.org/citation.
  cfm?id=2387880.2387906

<a id="lietal2014">
* Cheng Li, Joao Leit ˜ ao, Allen Clement, Nuno M. Pregui ˜ c¸a, Rodrigo Rodrigues, and
  Viktor Vafeiadis. 2014. Automating the Choice of Consistency Levels in Replicated Systems. In USENIX Annual Technical Conference (ATC), 2014. 281–292.
  https://www.usenix.org/conference/atc14/technical-sessions/
  presentation/li_cheng_2

<a id="yuandvahdat2002">
* Haifeng Yu and Amin Vahdat. 2002. Design and evaluation of a conit-based continuous consistency model for replicated services. ACM Transactions on Computer Systems (TOCS) 20, 3
  (2002), 239–282.

<a id="santosetal2007">
* Nuno Santos, Lu´ıs Veiga, and Paulo Ferreira. 2007. Vector-Field Consistency for Ad-Hoc Gaming.
  In ACM/IFIP/USENIX Middleware Conference, 2007. 80–100.

<a id="chihoubetal2012">
* Houssem-Eddine Chihoub, Shadi Ibrahim, Gabriel Antoniu, and Mar´ıa S. Perez-Hern ´ andez. 2013. ´
  Consistency in the Cloud: When Money Does Matter!. In Symposium on Cluster, Cloud, and
  Grid Computing (CCGrid), 2013. 352–359.

<a id="sivaramakrishnanetal2015">
* Krishnamoorthy C. Sivaramakrishnan, Gowtham Kaki, and Suresh Jagannathan. 2015. Declarative programming over eventually consistent data stores. In ACM SIGPLAN Conference
  on Programming Language Design and Implementation, 2015. 413–424. DOI:http:
  //dx.doi.org/10.1145/2737924.2737981

<a id="balegasetal2015">
* Valter Balegas, Sergio Duarte, Carla Ferreira, Rodrigo Rodrigues, Nuno M. Pregui ´ c¸a, Mahsa
  Najafzadeh, and Marc Shapiro. 2015. Putting consistency back into eventual consistency. In
  European Conference on Computer Systems (EuroSys), 2015. 6. DOI:http://dx.doi.
  org/10.1145/2741948.2741972

<a id="goodman1989">
* James R Goodman. 1989. Cache consistency and sequential consistency. Technical Report no. 61. SCI Commitee.

<a id="ahamadetal1993">
* Mustaque Ahamad, Rida A. Bazzi, Ranjit John, Prince Kohli, and Gil Neiger. 1993. The Power of
  Processor Consistency. In ACM Symposium on Parallel Algorithms and Architectures (SPAA), 1993. 251–260. DOI:http://dx.doi.org/10.1145/165231.165264

<a id="iftodeetal1996a">
* Liviu Iftode, Cezary Dubnicki, Edward W. Felten, and Kai Li. 1996a. Improving ReleaseConsistent Shared Virtual Memory Using Automatic Update. In IEEE International Symposium
  on High-Performance Computer Architecture (HPCA), 1996. 14–25. DOI:http://dx.doi.
  org/10.1109/HPCA.1996.501170

<a id="iftodeetal1996b">
* Liviu Iftode, Jaswinder Pal Singh, and Kai Li. 1996b. Scope Consistency: A Bridge Between
  Release Consistency and Entry Consistency. In ACM Symposium on Parallel Algorithms and
  Architectures (SPAA), 1996. 277–287.

<a id="gaoandsarkar2000">
* Guang R. Gao and Vivek Sarkar. 2000. Location Consistency-A New Memory Model and
  Cache Consistency Protocol. IEEE Trans. Comput. 49, 8 (2000), 798–813. DOI:http:
  //dx.doi.org/10.1109/12.868026

<a id="adveandgharachorloo1996">
* Sarita V. Adve and Kourosh Gharachorloo. 1996. Shared Memory Consistency Models: A
  Tutorial. IEEE Computer 29, 12 (1996), 66–76.

<a id="adveandhill1993">
* Sarita V. Adve and Mark D. Hill. 1993. A Unified Formalization of Four Shared-Memory
  Models. IEEE Transactions on Parallel and Distributed Systems 4, 6 (1993), 613–624. DOI:
  http://dx.doi.org/10.1109/71.242161

<a id="raynalandschiper1997">
* Michel Raynal and Andre Schiper. 1997. A suite of definitions for consistency criteria in
  distributed shared memories. Annales des Telecommunications ´ 52, 11-12 (1997), 652–661.
  DOI:http://dx.doi.org/10.1007/BF02997620

<a id="batallerandbernabéuaubán1997">
* Jordi Bataller and Jose M. Bernabéu-Aubán. 1997. Synchronized DSM Models. In ´ Parallel Processing (Euro-Par), 1997. 468–475. DOI:http://dx.doi.org/10.1007/
  BFb0002771

<a id="misra1986">
* Jayadev Misra. 1986. Axioms for Memory Access in Asynchronous Hardware Systems. ACM
  Transactions on Programming Languages and Systems (TOPLAS) 8, 1 (1986), 142–153.

<a id="gibbonsanddorach1997">
* Phillip B. Gibbons and Ephraim Korach. 1997. Testing Shared Memories. SIAM Journal on
  Computing (SICOMP) 26, 4 (1997), 1208–1244. DOI:http://dx.doi.org/10.1137/
  S0097539794279614

<a id="andersonetal2010">
* Eric Anderson, Xiaozhou Li, Mehul A. Shah, Joseph Tucek, and Jay J. Wylie. 2010. What Consistency Does Your Key-value Store Actually Provide?. In Hot Topics in System Dependability
  (HotDep’10). USENIX Association, Berkeley, CA, USA, 1–16. http://dl.acm.org/
  citation.cfm?id=1924908.1924919

<a id="wadaetal2011">
* Hiroshi Wada, Alan Fekete, Liang Zhao, Kevin Lee, and Anna Liu. 2011. Data Consistency
  Properties and the Trade-offs in Commercial Cloud Storage: the Consumers’ Perspective. In
  Conference on Innovative Data Systems Research (CIDR), 2011. 134–143.

<a id="patiletal2011">
* Swapnil Patil, Milo Polte, Kai Ren, Wittawat Tantisiriroj, Lin Xiao, Julio Lopez, Garth Gibson,
  Adam Fuchs, and Billie Rinaldi. 2011. YCSB++: benchmarking and performance debugging
  advanced features in scalable table stores. In ACM Symposium on Cloud Computing (SOCC)
  in conjunction with SOSP 2011. 9. DOI:http://dx.doi.org/10.1145/2038916.
  2038925

<a id="rahmanetal2012">
* Muntasir Raihan Rahman, Wojciech M. Golab, Alvin AuYoung, Kimberly Keeton, and Jay J.
  Wylie. 2012. Toward a Principled Framework for Benchmarking Consistency. Computing
  Research Repository abs/1211.4290 (2012).

<a id="luetal2015">
* Haonan Lu, Kaushik Veeraraghavan, Philippe Ajoux, Jim Hunt, Yee Jiun Song, Wendy Tobagus,
  Sanjeev Kumar, and Wyatt Lloyd. 2015. Existential consistency: measuring and understanding
  consistency at Facebook. In ACM Symposium on Operating Systems Principles (SOSP), 2015.
  295–310. DOI:http://dx.doi.org/10.1145/2815400.2815426

<a id="harrisetal2010">
* Tim Harris, James R. Larus, and Ravi Rajwar. 2010. Transactional Memory, 2nd
  edition. Morgan & Claypool Publishers. DOI:http://dx.doi.org/10.2200/
  S00272ED1V01Y201006CAC011

<a id="dziumaetal2014">
* Dmytro Dziuma, Panagiota Fatourou, and Eleni Kanellou. 2014. Consistency for Transactional
  Memory Computing. Bulletin of the EATCS 113 (2014). http://eatcs.org/beatcs/
  index.php/beatcs/article/view/288

# 附录A 一致性谓词总结

$$
\begin{array}{l|l}
L_{INEARIZABILITY}(\mathcal{F}) & S_{INGLE}O_{RDER} \land R_{EAL}T_{IME} \land RV_{AL}(\mathcal({F}) \\
S_{INGLE}O_{RDER} & \exists H' \subseteq {op \in H : op.oval = \nabla} : vis = ar \setminus (H' \times H) \\
R_{EAL}T_{IME} & rb \subseteq ar \\
R_{EGULAR}(\mathcal{F}) & S_{INGLE}O_{RDER} \land R_{EAL}T_{IME}W_{RITES} \land RV_{AL}(\mathcal{F}) \\
S_{AFE}(\mathcal{F}) & S_{INGLE}O_{RDER} \land R_{EAL}T_{IME}W_{RITES} \land S_{EQ}RV_{AL}(\mathcal{F}) \\
R_{EAL}T_{IME}W_{RITES} & rb|_{wr \rightarrow op} \subseteq ar \\
S_{EQ}RV_{AL}(\mathcal{F}) & \forall op \in H : Concur(op)=\emptyset \implies op.oval \in \mathcal{F}(op,cxt(A,op)) \\
E_{VENTUAL}C_{ONSISTENCY}(\mathcal{F}) & E_{VENTUAL}V_{ISIBILITY} \land N_{O}C_{IRCULAR}C_{AUSALITY} \land RV_{AL} \\
E_{VENTUAL}V_{ISIBILITY} & \forall a \in H, \forall [f] \in H / \approx_{ss} : | { b \in [f]:(a \xrightarrow{rb} b) \land (a \not\xrightarrow{vis} b)}| < \infty \\
N_{O}C_{IRCULAR}C_{AUSALITY} & acyclic(hb) \\
S_{TRONG}C_{ONVERGENCE} & \forall a,b \in H|_{rd}:vis^{-1}(a)|_{wr}=vis^{-1}(b)|_{wr} \implies a.oval=b.oval \\
S_{TRONG}E_{VENTUAL}C_{ONS.}(\mathcal{F}) & E_{VENTUAL}C_{ONSISTENCY}(\mathcal{F}) \land S_{TRONG}C_{ONVERGENCE} \\
Q_{UIESCENT}C_{ONSISTENCY}(\mathcal{F}) & |H|_{wr}| < \infty \implies \exists C \in \mathcal{C}: \forall [f] \in H/\approx_{ss}: |\{op \in [f] : op.oval \not\in \mathcal{F}(op,C)\}| < \infty \\
PRAM & so \subseteq vis \\
S_{EQUENTIAL}C_{ONSISTENCY}(\mathcal{F}) & S_{INGLE}O_{RDER} \land PRAMC_{ONSISTENCY} \land RV_{AL}(\mathcal{F}) \\
M_{ONOTONIC}R_{EADS} & \forall a \in H, \forall b,c \in H|_{rd} : a \xrightarrow{vis} b \land b \xrightarrow{so} c \implies a \xrightarrow{vis} c \triangleq (vis;so|_{rd->rd}) \subseteq ar \\
R_{EAD}Y_{OUR}W_{RITES} & \forall a \in H|_{wr}, \forall b \in H|_{rd} : a \xrightarrow{so} b \implies a \xrightarrow{vis} b \triangleq so|_{wr \rightarrow rd} \subseteq vis \\
M_{ONOTONIC}W_{RITES} & \forall a,b \in H|_{wr} : a \xrightarrow{so} b \implies a \xrightarrow{ar} b \triangleq so|_{wr \rightarrow wr} \subseteq ar \\
W_{RITES}F_{OLLOW}R_{EADS} & \forall a,c \in H|_{wr}, \forall b \in H|_{rd}: a \xrightarrow{vis} b \land b \xrightarrow{so} c \implies a \xrightarrow{ar} c \triangleq (vis;so|_{rd \rightarrow wr}) \subseteq ar \\
C_{AUSAL}V_{ISIBILITY} & hb \subseteq vis \\
C_{AUSAL}A_{RBITRATION} & hb \subseteq ar \\
C_{AUSALITY}(\mathcal{F}) & C_{AUSAL}V_{ISIBILITY} \land C_{AUSAL}A_{RBITRATION} \land RV_{AL}(\mathcal{F}) \\
C_{AUSAL+}(\mathcal{F}) & C_{AUSALITY}(\mathcal{F}) \land S_{TRONG}C_{ONVERGENCE} \\
R_{EAL}T_{IME}C_{AUSALITY}(\mathcal{F}) & C_{AUSALITY}(\mathcal{F}) \land R_{EAL}T_{IME} \\
T_{IMED}V_{ISIBILITY}(\Delta) & \forall a \in H|_{wr}, \forall b \in H, \forall t \in Time: a.rtime = t \land b.stime = t + \Delta \implies a \xrightarrow{vis} b \\
T_{IMED}C_{AUSALITY}(\mathcal{F},\Delta) & C_{AUSALITY}(\mathcal{F}) \land T_{IMED}V_{ISIBILITY}(\Delta) \\
T_{IMED}L_{INERIZABILITY}(\mathcal{F},\Delta) & S_{INGLE}O_{RDER} \land T_{IMED}V_{ISIBILITY}(\Delta) \land RV_{AL}(\mathcal{F}) \\
P_{REFIX}S_{EQUENTIAL}(\mathcal{F}) & S_{INGLE}O_{RDER} \land M_{ONOTONIC}W_{RITES} \land RV_{AL}(\mathcal{F}) \\
P_{REFIX}L_{INEARIZABLE}(\mathcal{F}) & S_{INGLE}O_{RDER} \land R_{EAL}T_{IME}WW \land RV_{AL}(\mathcal{F}) \\
R_{EAL}T_{IME}WW & rb|_{wr \rightarrow wr} \subseteq ar \\
K-L_{INEARIZABLE}(\mathcal{F},\mathcal{K}) & S_{INGLE}O_{RDER} \land R_{EAL}T_{IME}WW \land K-R_{EAL}T_{IME}R_{EADS}(\mathcal{K}) \land RV_{AL}(\mathcal{F}) \\
K-R_{EAL}T_{IME}R_{EADS}(\mathcal{K}) & \forall a \in H|_{wr}, \forall b \in H|_{rd}, \forall PW \in H|_{wr}, \forall pw \in PW: |PW| < \mathcal{K} \land a \xrightarrow{ar} pw \land pw \xrightarrow{rb} b \land a \xrightarrow{rb} b \implies a \xrightarrow{ar} b \\

\end{array}
$$